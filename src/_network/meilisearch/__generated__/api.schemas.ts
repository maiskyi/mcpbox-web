/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * meilisearch
 * Meilisearch HTTP server
 * OpenAPI spec version: 1.15.2
 */
export type Action = typeof Action[keyof typeof Action];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Action = {
  '*': '*',
  search: 'search',
  'documents*': 'documents.*',
  documentsadd: 'documents.add',
  documentsget: 'documents.get',
  documentsdelete: 'documents.delete',
  'indexes*': 'indexes.*',
  indexescreate: 'indexes.create',
  indexesget: 'indexes.get',
  indexesupdate: 'indexes.update',
  indexesdelete: 'indexes.delete',
  indexesswap: 'indexes.swap',
  'tasks*': 'tasks.*',
  taskscancel: 'tasks.cancel',
  tasksdelete: 'tasks.delete',
  tasksget: 'tasks.get',
  'settings*': 'settings.*',
  settingsget: 'settings.get',
  settingsupdate: 'settings.update',
  'stats*': 'stats.*',
  statsget: 'stats.get',
  'metrics*': 'metrics.*',
  metricsget: 'metrics.get',
  'dumps*': 'dumps.*',
  dumpscreate: 'dumps.create',
  'snapshots*': 'snapshots.*',
  snapshotscreate: 'snapshots.create',
  version: 'version',
  keyscreate: 'keys.create',
  keysget: 'keys.get',
  keysupdate: 'keys.update',
  keysdelete: 'keys.delete',
  experimentalget: 'experimental.get',
  experimentalupdate: 'experimental.update',
  networkget: 'network.get',
  networkupdate: 'network.update',
  chatCompletions: 'chatCompletions',
  'chats*': 'chats.*',
  chatsget: 'chats.get',
  chatsdelete: 'chats.delete',
  'chatsSettings*': 'chatsSettings.*',
  chatsSettingsget: 'chatsSettings.get',
  chatsSettingsupdate: 'chatsSettings.update',
} as const;

/**
 * @minimum 0
 */
export type AllBatchesFrom = number | null;

/**
 * @minimum 0
 */
export type AllBatchesNext = number | null;

export interface AllBatches {
  results: BatchView[];
  /** @minimum 0 */
  total: number;
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  from?: AllBatchesFrom;
  /** @minimum 0 */
  next?: AllBatchesNext;
}

/**
 * The first task uid returned.
 * @minimum 0
 */
export type AllTasksFrom = number | null;

/**
 * Represents the value to send in from to fetch the next slice of the results. The first item for the next slice starts at this exact number. When the returned value is null, it means that all the data have been browsed in the given order.
 * @minimum 0
 */
export type AllTasksNext = number | null;

export interface AllTasks {
  /** The list of tasks that matched the filter. */
  results: TaskView[];
  /**
   * Total number of browsable results using offset/limit parameters for the given resource.
   * @minimum 0
   */
  total: number;
  /**
   * Limit given for the query. If limit is not provided as a query parameter, this parameter displays the default limit value.
   * @minimum 0
   */
  limit: number;
  /**
   * The first task uid returned.
   * @minimum 0
   */
  from?: AllTasksFrom;
  /**
   * Represents the value to send in from to fetch the next slice of the results. The first item for the next slice starts at this exact number. When the returned value is null, it means that all the data have been browsed in the given order.
   * @minimum 0
   */
  next?: AllTasksNext;
}

export interface AttributePatterns {
  patterns: string[];
}

export type BTreeMapItemIndices = number[] | null;

export type BTreeMapItem = {
  /** @minimum 0 */
  start: number;
  /** @minimum 0 */
  length: number;
  indices?: BTreeMapItemIndices;
};

export interface BTreeMap {[key: string]: BTreeMapItem[]}

export type BatchStatsStatus = {[key: string]: number};

export type BatchStatsTypes = {[key: string]: number};

export type BatchStatsIndexUids = {[key: string]: number};

export type BatchStatsProgressTrace = {[key: string]: unknown};

export type BatchStatsWriteChannelCongestionAnyOf = {[key: string]: unknown};

export type BatchStatsWriteChannelCongestion = BatchStatsWriteChannelCongestionAnyOf | null;

export type BatchStatsInternalDatabaseSizes = {[key: string]: unknown};

export interface BatchStats {
  totalNbTasks: U32;
  status: BatchStatsStatus;
  types: BatchStatsTypes;
  indexUids: BatchStatsIndexUids;
  progressTrace?: BatchStatsProgressTrace;
  writeChannelCongestion?: BatchStatsWriteChannelCongestion;
  internalDatabaseSizes?: BatchStatsInternalDatabaseSizes;
}

export type BatchViewProgress = null | ProgressView;

export type BatchViewDuration = string | null;

export type BatchViewFinishedAt = string | null;

export interface BatchView {
  uid: U32;
  progress?: BatchViewProgress;
  details: DetailsView;
  stats: BatchStats;
  duration?: BatchViewDuration;
  startedAt?: string;
  finishedAt?: BatchViewFinishedAt;
  batchStrategy?: string;
}

export type BrowseQueryFields = string[] | null;

export type BrowseQueryIds = string[] | null;

export interface BrowseQuery {
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  limit: number;
  fields?: BrowseQueryFields;
  retrieveVectors: boolean;
  ids?: BrowseQueryIds;
  filter?: unknown;
}

export type ChatSearchParamsHybrid = null | HybridQuery;

/**
 * @minimum 0
 */
export type ChatSearchParamsLimit = number | null;

export type ChatSearchParamsSort = string[] | null;

export type ChatSearchParamsDistinct = string | null;

export type ChatSearchParamsMatchingStrategy = null | MatchingStrategy;

export type ChatSearchParamsAttributesToSearchOn = string[] | null;

export type ChatSearchParamsRankingScoreThreshold = null | RankingScoreThreshold;

export interface ChatSearchParams {
  hybrid?: ChatSearchParamsHybrid;
  /** @minimum 0 */
  limit?: ChatSearchParamsLimit;
  sort?: ChatSearchParamsSort;
  distinct?: ChatSearchParamsDistinct;
  matchingStrategy?: ChatSearchParamsMatchingStrategy;
  attributesToSearchOn?: ChatSearchParamsAttributesToSearchOn;
  rankingScoreThreshold?: ChatSearchParamsRankingScoreThreshold;
}

export type ChatSettingsDescription = string | null;

/**
 * A liquid template used to render documents to a text that can be embedded.

Meillisearch interpolates the template for each document and sends the resulting text to the embedder.
The embedder then generates document vectors based on this text.
 */
export type ChatSettingsDocumentTemplate = string | null;

/**
 * Rendered texts are truncated to this size. Defaults to 400.
 * @minimum 0
 */
export type ChatSettingsDocumentTemplateMaxBytes = number | null;

export type ChatSettingsSearchParameters = null | ChatSearchParams;

export interface ChatSettings {
  description?: ChatSettingsDescription;
  /** A liquid template used to render documents to a text that can be embedded.

Meillisearch interpolates the template for each document and sends the resulting text to the embedder.
The embedder then generates document vectors based on this text. */
  documentTemplate?: ChatSettingsDocumentTemplate;
  /**
   * Rendered texts are truncated to this size. Defaults to 400.
   * @minimum 0
   */
  documentTemplateMaxBytes?: ChatSettingsDocumentTemplateMaxBytes;
  searchParameters?: ChatSettingsSearchParameters;
}

export type Code = typeof Code[keyof typeof Code];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Code = {
  api_key_already_exists: 'api_key_already_exists',
  api_key_not_found: 'api_key_not_found',
  bad_parameter: 'bad_parameter',
  bad_request: 'bad_request',
  database_size_limit_reached: 'database_size_limit_reached',
  document_not_found: 'document_not_found',
  dump_already_processing: 'dump_already_processing',
  dump_not_found: 'dump_not_found',
  dump_process_failed: 'dump_process_failed',
  duplicate_index_found: 'duplicate_index_found',
  immutable_api_key_actions: 'immutable_api_key_actions',
  immutable_api_key_created_at: 'immutable_api_key_created_at',
  immutable_api_key_expires_at: 'immutable_api_key_expires_at',
  immutable_api_key_indexes: 'immutable_api_key_indexes',
  immutable_api_key_key: 'immutable_api_key_key',
  immutable_api_key_uid: 'immutable_api_key_uid',
  immutable_api_key_updated_at: 'immutable_api_key_updated_at',
  immutable_index_created_at: 'immutable_index_created_at',
  immutable_index_uid: 'immutable_index_uid',
  immutable_index_updated_at: 'immutable_index_updated_at',
  index_already_exists: 'index_already_exists',
  index_creation_failed: 'index_creation_failed',
  index_not_found: 'index_not_found',
  index_primary_key_already_exists: 'index_primary_key_already_exists',
  index_primary_key_multiple_candidates_found: 'index_primary_key_multiple_candidates_found',
  index_primary_key_no_candidate_found: 'index_primary_key_no_candidate_found',
  internal: 'internal',
  invalid_api_key: 'invalid_api_key',
  invalid_api_key_actions: 'invalid_api_key_actions',
  invalid_api_key_description: 'invalid_api_key_description',
  invalid_api_key_expires_at: 'invalid_api_key_expires_at',
  invalid_api_key_indexes: 'invalid_api_key_indexes',
  invalid_api_key_limit: 'invalid_api_key_limit',
  invalid_api_key_name: 'invalid_api_key_name',
  invalid_api_key_offset: 'invalid_api_key_offset',
  invalid_api_key_uid: 'invalid_api_key_uid',
  invalid_content_type: 'invalid_content_type',
  invalid_document_csv_delimiter: 'invalid_document_csv_delimiter',
  invalid_document_fields: 'invalid_document_fields',
  invalid_document_retrieve_vectors: 'invalid_document_retrieve_vectors',
  missing_document_filter: 'missing_document_filter',
  missing_document_edition_function: 'missing_document_edition_function',
  invalid_document_filter: 'invalid_document_filter',
  invalid_document_geo_field: 'invalid_document_geo_field',
  invalid_vector_dimensions: 'invalid_vector_dimensions',
  invalid_vectors_type: 'invalid_vectors_type',
  invalid_document_id: 'invalid_document_id',
  invalid_document_ids: 'invalid_document_ids',
  invalid_document_limit: 'invalid_document_limit',
  invalid_document_offset: 'invalid_document_offset',
  invalid_search_embedder: 'invalid_search_embedder',
  invalid_similar_embedder: 'invalid_similar_embedder',
  invalid_search_hybrid_query: 'invalid_search_hybrid_query',
  invalid_index_limit: 'invalid_index_limit',
  invalid_index_offset: 'invalid_index_offset',
  invalid_index_primary_key: 'invalid_index_primary_key',
  invalid_index_uid: 'invalid_index_uid',
  invalid_multi_search_facets: 'invalid_multi_search_facets',
  invalid_multi_search_facets_by_index: 'invalid_multi_search_facets_by_index',
  invalid_multi_search_facet_order: 'invalid_multi_search_facet_order',
  invalid_multi_search_federated: 'invalid_multi_search_federated',
  invalid_multi_search_federation_options: 'invalid_multi_search_federation_options',
  invalid_multi_search_max_values_per_facet: 'invalid_multi_search_max_values_per_facet',
  invalid_multi_search_merge_facets: 'invalid_multi_search_merge_facets',
  invalid_multi_search_query_facets: 'invalid_multi_search_query_facets',
  invalid_multi_search_query_pagination: 'invalid_multi_search_query_pagination',
  invalid_multi_search_query_ranking_rules: 'invalid_multi_search_query_ranking_rules',
  invalid_multi_search_query_position: 'invalid_multi_search_query_position',
  invalid_multi_search_remote: 'invalid_multi_search_remote',
  invalid_multi_search_weight: 'invalid_multi_search_weight',
  invalid_network_remotes: 'invalid_network_remotes',
  invalid_network_self: 'invalid_network_self',
  invalid_network_search_api_key: 'invalid_network_search_api_key',
  invalid_network_url: 'invalid_network_url',
  invalid_search_attributes_to_search_on: 'invalid_search_attributes_to_search_on',
  invalid_search_attributes_to_crop: 'invalid_search_attributes_to_crop',
  invalid_search_attributes_to_highlight: 'invalid_search_attributes_to_highlight',
  invalid_similar_attributes_to_retrieve: 'invalid_similar_attributes_to_retrieve',
  invalid_similar_retrieve_vectors: 'invalid_similar_retrieve_vectors',
  invalid_search_attributes_to_retrieve: 'invalid_search_attributes_to_retrieve',
  invalid_search_ranking_score_threshold: 'invalid_search_ranking_score_threshold',
  invalid_similar_ranking_score_threshold: 'invalid_similar_ranking_score_threshold',
  invalid_search_retrieve_vectors: 'invalid_search_retrieve_vectors',
  invalid_search_crop_length: 'invalid_search_crop_length',
  invalid_search_crop_marker: 'invalid_search_crop_marker',
  invalid_search_facets: 'invalid_search_facets',
  invalid_search_semantic_ratio: 'invalid_search_semantic_ratio',
  invalid_search_locales: 'invalid_search_locales',
  invalid_facet_search_exhaustive_facet_count: 'invalid_facet_search_exhaustive_facet_count',
  invalid_facet_search_facet_name: 'invalid_facet_search_facet_name',
  invalid_similar_id: 'invalid_similar_id',
  invalid_search_filter: 'invalid_search_filter',
  invalid_similar_filter: 'invalid_similar_filter',
  invalid_search_highlight_post_tag: 'invalid_search_highlight_post_tag',
  invalid_search_highlight_pre_tag: 'invalid_search_highlight_pre_tag',
  invalid_search_hits_per_page: 'invalid_search_hits_per_page',
  invalid_similar_limit: 'invalid_similar_limit',
  invalid_search_limit: 'invalid_search_limit',
  invalid_search_matching_strategy: 'invalid_search_matching_strategy',
  invalid_similar_offset: 'invalid_similar_offset',
  invalid_search_offset: 'invalid_search_offset',
  invalid_search_page: 'invalid_search_page',
  invalid_search_q: 'invalid_search_q',
  invalid_facet_search_query: 'invalid_facet_search_query',
  invalid_facet_search_name: 'invalid_facet_search_name',
  facet_search_disabled: 'facet_search_disabled',
  invalid_search_vector: 'invalid_search_vector',
  invalid_search_show_matches_position: 'invalid_search_show_matches_position',
  invalid_search_show_ranking_score: 'invalid_search_show_ranking_score',
  invalid_similar_show_ranking_score: 'invalid_similar_show_ranking_score',
  invalid_search_show_ranking_score_details: 'invalid_search_show_ranking_score_details',
  invalid_similar_show_ranking_score_details: 'invalid_similar_show_ranking_score_details',
  invalid_search_sort: 'invalid_search_sort',
  invalid_search_distinct: 'invalid_search_distinct',
  invalid_settings_displayed_attributes: 'invalid_settings_displayed_attributes',
  invalid_settings_distinct_attribute: 'invalid_settings_distinct_attribute',
  invalid_settings_proximity_precision: 'invalid_settings_proximity_precision',
  invalid_settings_facet_search: 'invalid_settings_facet_search',
  invalid_settings_prefix_search: 'invalid_settings_prefix_search',
  invalid_settings_faceting: 'invalid_settings_faceting',
  invalid_settings_filterable_attributes: 'invalid_settings_filterable_attributes',
  invalid_settings_pagination: 'invalid_settings_pagination',
  invalid_settings_search_cutoff_ms: 'invalid_settings_search_cutoff_ms',
  invalid_settings_embedders: 'invalid_settings_embedders',
  invalid_settings_ranking_rules: 'invalid_settings_ranking_rules',
  invalid_settings_searchable_attributes: 'invalid_settings_searchable_attributes',
  invalid_settings_sortable_attributes: 'invalid_settings_sortable_attributes',
  invalid_settings_stop_words: 'invalid_settings_stop_words',
  invalid_settings_non_separator_tokens: 'invalid_settings_non_separator_tokens',
  invalid_settings_separator_tokens: 'invalid_settings_separator_tokens',
  invalid_settings_dictionary: 'invalid_settings_dictionary',
  invalid_settings_synonyms: 'invalid_settings_synonyms',
  invalid_settings_typo_tolerance: 'invalid_settings_typo_tolerance',
  invalid_settings_localized_attributes: 'invalid_settings_localized_attributes',
  invalid_state: 'invalid_state',
  invalid_store_file: 'invalid_store_file',
  invalid_swap_duplicate_index_found: 'invalid_swap_duplicate_index_found',
  invalid_swap_indexes: 'invalid_swap_indexes',
  invalid_task_after_enqueued_at: 'invalid_task_after_enqueued_at',
  invalid_task_after_finished_at: 'invalid_task_after_finished_at',
  invalid_task_after_started_at: 'invalid_task_after_started_at',
  invalid_task_before_enqueued_at: 'invalid_task_before_enqueued_at',
  invalid_task_before_finished_at: 'invalid_task_before_finished_at',
  invalid_task_before_started_at: 'invalid_task_before_started_at',
  invalid_task_canceled_by: 'invalid_task_canceled_by',
  invalid_task_from: 'invalid_task_from',
  invalid_task_limit: 'invalid_task_limit',
  invalid_task_reverse: 'invalid_task_reverse',
  invalid_task_statuses: 'invalid_task_statuses',
  invalid_task_types: 'invalid_task_types',
  invalid_task_uids: 'invalid_task_uids',
  invalid_batch_uids: 'invalid_batch_uids',
  io_error: 'io_error',
  feature_not_enabled: 'feature_not_enabled',
  malformed_payload: 'malformed_payload',
  max_fields_limit_exceeded: 'max_fields_limit_exceeded',
  missing_api_key_actions: 'missing_api_key_actions',
  missing_api_key_expires_at: 'missing_api_key_expires_at',
  missing_api_key_indexes: 'missing_api_key_indexes',
  missing_authorization_header: 'missing_authorization_header',
  missing_content_type: 'missing_content_type',
  missing_document_id: 'missing_document_id',
  missing_facet_search_facet_name: 'missing_facet_search_facet_name',
  missing_index_uid: 'missing_index_uid',
  missing_master_key: 'missing_master_key',
  missing_network_url: 'missing_network_url',
  missing_payload: 'missing_payload',
  missing_search_hybrid: 'missing_search_hybrid',
  missing_swap_indexes: 'missing_swap_indexes',
  missing_task_filters: 'missing_task_filters',
  no_space_left_on_device: 'no_space_left_on_device',
  payload_too_large: 'payload_too_large',
  remote_bad_response: 'remote_bad_response',
  remote_bad_request: 'remote_bad_request',
  remote_could_not_send_request: 'remote_could_not_send_request',
  remote_invalid_api_key: 'remote_invalid_api_key',
  remote_remote_error: 'remote_remote_error',
  remote_timeout: 'remote_timeout',
  too_many_search_requests: 'too_many_search_requests',
  task_not_found: 'task_not_found',
  task_file_not_found: 'task_file_not_found',
  batch_not_found: 'batch_not_found',
  too_many_open_files: 'too_many_open_files',
  too_many_vectors: 'too_many_vectors',
  unretrievable_document: 'unretrievable_document',
  unretrievable_error_code: 'unretrievable_error_code',
  unsupported_media_type: 'unsupported_media_type',
  vector_embedding_error: 'vector_embedding_error',
  not_found_similar_id: 'not_found_similar_id',
  invalid_document_edition_context: 'invalid_document_edition_context',
  invalid_document_edition_function_filter: 'invalid_document_edition_function_filter',
  edit_documents_by_function_error: 'edit_documents_by_function_error',
  invalid_settings_index_chat: 'invalid_settings_index_chat',
  unimplemented_external_function_calling: 'unimplemented_external_function_calling',
  unimplemented_non_streaming_chat_completions: 'unimplemented_non_streaming_chat_completions',
  unimplemented_multi_choice_chat_completions: 'unimplemented_multi_choice_chat_completions',
  chat_not_found: 'chat_not_found',
  invalid_chat_setting_document_template: 'invalid_chat_setting_document_template',
  invalid_chat_completion_org_id: 'invalid_chat_completion_org_id',
  invalid_chat_completion_project_id: 'invalid_chat_completion_project_id',
  invalid_chat_completion_api_version: 'invalid_chat_completion_api_version',
  invalid_chat_completion_deployment_id: 'invalid_chat_completion_deployment_id',
  invalid_chat_completion_source: 'invalid_chat_completion_source',
  invalid_chat_completion_base_api: 'invalid_chat_completion_base_api',
  invalid_chat_completion_api_key: 'invalid_chat_completion_api_key',
  invalid_chat_completion_prompts: 'invalid_chat_completion_prompts',
  invalid_chat_completion_system_prompt: 'invalid_chat_completion_system_prompt',
  invalid_chat_completion_search_description_prompt: 'invalid_chat_completion_search_description_prompt',
  invalid_chat_completion_search_query_param_prompt: 'invalid_chat_completion_search_query_param_prompt',
  invalid_chat_completion_search_index_uid_param_prompt: 'invalid_chat_completion_search_index_uid_param_prompt',
  invalid_chat_completion_pre_query_prompt: 'invalid_chat_completion_pre_query_prompt',
} as const;

export type ComputedFacetsDistribution = {[key: string]: {[key: string]: number}};

export type ComputedFacetsStats = {[key: string]: FacetStats};

export interface ComputedFacets {
  distribution: ComputedFacetsDistribution;
  stats: ComputedFacetsStats;
}

/**
 * A description for the key. `null` if empty.
 */
export type CreateApiKeyDescription = string | null;

/**
 * A human-readable name for the key. `null` if empty.
 */
export type CreateApiKeyName = string | null;

/**
 * Represent the expiration date and time as RFC 3339 format. `null` equals to no expiration time.
 */
export type CreateApiKeyExpiresAt = string | null;

export interface CreateApiKey {
  /** A description for the key. `null` if empty. */
  description?: CreateApiKeyDescription;
  /** A human-readable name for the key. `null` if empty. */
  name?: CreateApiKeyName;
  /** A uuid v4 to identify the API Key. If not specified, it's generated by Meilisearch. */
  uid: string;
  /** A list of actions permitted for the key. `["*"]` for all actions. The `*` character can be used as a wildcard when located at the last position. e.g. `documents.*` to authorize access on all documents endpoints. */
  actions: Action[];
  /** A list of accessible indexes permitted for the key. `["*"]` for all indexes. The `*` character can be used as a wildcard when located at the last position. e.g. `products_*` to allow access to all indexes whose names start with `products_`. */
  indexes: string[];
  /** Represent the expiration date and time as RFC 3339 format. `null` equals to no expiration time. */
  expiresAt?: CreateApiKeyExpiresAt;
}

export type DetailsViewAllOf = null | SettingsUnchecked;

/**
 * Number of documents received for documentAdditionOrUpdate task.
 * @minimum 0
 */
export type DetailsViewAllOfTwoReceivedDocuments = number | null;

/**
 * Number of documents finally indexed for documentAdditionOrUpdate task or a documentAdditionOrUpdate batch of tasks.
 * @minimum 0
 */
export type DetailsViewAllOfTwoIndexedDocuments = number | null;

/**
 * Number of documents edited for editDocumentByFunction task.
 * @minimum 0
 */
export type DetailsViewAllOfTwoEditedDocuments = number | null;

/**
 * Value for the primaryKey field encountered if any for indexCreation or indexUpdate task.
 */
export type DetailsViewAllOfTwoPrimaryKey = string | null;

/**
 * Number of provided document ids for the documentDeletion task.
 * @minimum 0
 */
export type DetailsViewAllOfTwoProvidedIds = number | null;

/**
 * Number of documents finally deleted for documentDeletion and indexDeletion tasks.
 * @minimum 0
 */
export type DetailsViewAllOfTwoDeletedDocuments = number | null;

/**
 * Number of tasks that match the request for taskCancelation or taskDeletion tasks.
 * @minimum 0
 */
export type DetailsViewAllOfTwoMatchedTasks = number | null;

/**
 * Number of tasks canceled for taskCancelation.
 * @minimum 0
 */
export type DetailsViewAllOfTwoCanceledTasks = number | null;

/**
 * Number of tasks deleted for taskDeletion.
 * @minimum 0
 */
export type DetailsViewAllOfTwoDeletedTasks = number | null;

/**
 * Original filter query for taskCancelation or taskDeletion tasks.
 */
export type DetailsViewAllOfTwoOriginalFilter = string | null;

/**
 * Identifier generated for the dump for dumpCreation task.
 */
export type DetailsViewAllOfTwoDumpUid = string | null;

export type DetailsViewAllOfTwoContextAnyOf = { [key: string]: unknown };

export type DetailsViewAllOfTwoContext = DetailsViewAllOfTwoContextAnyOf | null;

export type DetailsViewAllOfTwoFunction = string | null;

export type DetailsViewAllOfTwoSwaps = IndexSwap[] | null;

export type DetailsViewAllOfTwoUpgradeFrom = string | null;

export type DetailsViewAllOfTwoUpgradeTo = string | null;

export type DetailsViewAllOfTwo = {
  /**
   * Number of documents received for documentAdditionOrUpdate task.
   * @minimum 0
   */
  receivedDocuments?: DetailsViewAllOfTwoReceivedDocuments;
  /**
   * Number of documents finally indexed for documentAdditionOrUpdate task or a documentAdditionOrUpdate batch of tasks.
   * @minimum 0
   */
  indexedDocuments?: DetailsViewAllOfTwoIndexedDocuments;
  /**
   * Number of documents edited for editDocumentByFunction task.
   * @minimum 0
   */
  editedDocuments?: DetailsViewAllOfTwoEditedDocuments;
  /** Value for the primaryKey field encountered if any for indexCreation or indexUpdate task. */
  primaryKey?: DetailsViewAllOfTwoPrimaryKey;
  /**
   * Number of provided document ids for the documentDeletion task.
   * @minimum 0
   */
  providedIds?: DetailsViewAllOfTwoProvidedIds;
  /**
   * Number of documents finally deleted for documentDeletion and indexDeletion tasks.
   * @minimum 0
   */
  deletedDocuments?: DetailsViewAllOfTwoDeletedDocuments;
  /**
   * Number of tasks that match the request for taskCancelation or taskDeletion tasks.
   * @minimum 0
   */
  matchedTasks?: DetailsViewAllOfTwoMatchedTasks;
  /**
   * Number of tasks canceled for taskCancelation.
   * @minimum 0
   */
  canceledTasks?: DetailsViewAllOfTwoCanceledTasks;
  /**
   * Number of tasks deleted for taskDeletion.
   * @minimum 0
   */
  deletedTasks?: DetailsViewAllOfTwoDeletedTasks;
  /** Original filter query for taskCancelation or taskDeletion tasks. */
  originalFilter?: DetailsViewAllOfTwoOriginalFilter;
  /** Identifier generated for the dump for dumpCreation task. */
  dumpUid?: DetailsViewAllOfTwoDumpUid;
  context?: DetailsViewAllOfTwoContext;
  function?: DetailsViewAllOfTwoFunction;
  swaps?: DetailsViewAllOfTwoSwaps;
  upgradeFrom?: DetailsViewAllOfTwoUpgradeFrom;
  upgradeTo?: DetailsViewAllOfTwoUpgradeTo;
};

export type DetailsView = DetailsViewAllOf & DetailsViewAllOfTwo;

/**
 * Describes the mean and sigma of distribution of embedding similarity in the embedding space.

The intended use is to make the similarity score more comparable to the regular ranking score.
This allows to correct effects where results are too "packed" around a certain value.
 */
export interface DistributionShift {
  /** Value where the results are "packed".

Similarity scores are translated so that they are packed around 0.5 instead */
  current_mean: number;
  /** standard deviation of a similarity score.

Set below 0.4 to make the results less packed around the mean, and above 0.4 to make them more packed. */
  current_sigma: number;
}

export interface DocumentDeletionByFilter {
  filter: unknown;
}

export interface DocumentEditionByFunction {
  /** A string containing a RHAI function. */
  filter?: unknown;
  /** A string containing a filter expression. */
  context?: unknown;
  /** An object with data Meilisearch should make available for the editing function. */
  function: string;
}

export type EmbedderSource = typeof EmbedderSource[keyof typeof EmbedderSource];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmbedderSource = {
  openAi: 'openAi',
  huggingFace: 'huggingFace',
  ollama: 'ollama',
  userProvided: 'userProvided',
  rest: 'rest',
  composite: 'composite',
} as const;

export type ErrorType = typeof ErrorType[keyof typeof ErrorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorType = {
  internal: 'internal',
  invalid_request: 'invalid_request',
  auth: 'auth',
  system: 'system',
} as const;

export type FacetSearchQueryFacetQuery = string | null;

export type FacetSearchQueryQ = string | null;

export type FacetSearchQueryVector = number[] | null;

export type FacetSearchQueryHybrid = null | HybridQuery;

export type FacetSearchQueryAttributesToSearchOn = string[] | null;

export type FacetSearchQueryRankingScoreThreshold = null | RankingScoreThreshold;

export type FacetSearchQueryLocales = Locale[] | null;

export type FacetSearchQueryExhaustiveFacetCount = boolean | null;

export interface FacetSearchQuery {
  facet_query?: FacetSearchQueryFacetQuery;
  facet_name: string;
  q?: FacetSearchQueryQ;
  vector?: FacetSearchQueryVector;
  hybrid?: FacetSearchQueryHybrid;
  filter?: unknown;
  matching_strategy: MatchingStrategy;
  attributes_to_search_on?: FacetSearchQueryAttributesToSearchOn;
  ranking_score_threshold?: FacetSearchQueryRankingScoreThreshold;
  locales?: FacetSearchQueryLocales;
  exhaustive_facet_count?: FacetSearchQueryExhaustiveFacetCount;
}

export interface FacetStats {
  min: number;
  max: number;
}

export type FacetValuesSort = typeof FacetValuesSort[keyof typeof FacetValuesSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FacetValuesSort = {
  alpha: 'alpha',
  count: 'count',
} as const;

/**
 * @minimum 0
 */
export type FacetingSettingsMaxValuesPerFacet = number | null;

export type FacetingSettingsSortFacetValuesByAnyOf = {[key: string]: FacetValuesSort};

export type FacetingSettingsSortFacetValuesBy = FacetingSettingsSortFacetValuesByAnyOf | null;

export interface FacetingSettings {
  /** @minimum 0 */
  maxValuesPerFacet?: FacetingSettingsMaxValuesPerFacet;
  sortFacetValuesBy?: FacetingSettingsSortFacetValuesBy;
}

export interface FederatedFacets {[key: string]: ComputedFacets}

export type FederatedSearchFederation = null | Federation;

export interface FederatedSearch {
  queries: SearchQueryWithIndex[];
  federation?: FederatedSearchFederation;
}

/**
 * @minimum 0
 */
export type FederatedSearchResultAllOfSemanticHitCount = number | null;

export type FederatedSearchResultAllOfFacetDistributionAnyOf = {[key: string]: {[key: string]: number}};

export type FederatedSearchResultAllOfFacetDistribution = FederatedSearchResultAllOfFacetDistributionAnyOf | null;

export type FederatedSearchResultAllOfFacetStatsAnyOf = {[key: string]: FacetStats};

export type FederatedSearchResultAllOfFacetStats = FederatedSearchResultAllOfFacetStatsAnyOf | null;

export type FederatedSearchResultAllOfRemoteErrorsAnyOf = {[key: string]: ResponseError};

export type FederatedSearchResultAllOfRemoteErrors = FederatedSearchResultAllOfRemoteErrorsAnyOf | null;

export type FederatedSearchResultAllOf = {
  hits: SearchHit[];
  /** @minimum 0 */
  processingTimeMs: number;
  /** @minimum 0 */
  semanticHitCount?: FederatedSearchResultAllOfSemanticHitCount;
  facetDistribution?: FederatedSearchResultAllOfFacetDistribution;
  facetStats?: FederatedSearchResultAllOfFacetStats;
  facetsByIndex?: FederatedFacets;
  remoteErrors?: FederatedSearchResultAllOfRemoteErrors;
};

export type FederatedSearchResult = HitsInfo & FederatedSearchResultAllOf;

export type FederationFacetsByIndex = {[key: string]: string[] | null};

export type FederationMergeFacets = null | MergeFacets;

export interface Federation {
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  offset: number;
  facetsByIndex: FederationFacetsByIndex;
  mergeFacets?: FederationMergeFacets;
}

export type FederationOptionsRemote = string | null;

/**
 * @minimum 0
 */
export type FederationOptionsQueryPosition = number | null;

export interface FederationOptions {
  weight: number;
  remote?: FederationOptionsRemote;
  /** @minimum 0 */
  queryPosition?: FederationOptionsQueryPosition;
}

export interface FilterFeatures {
  equality?: boolean;
  comparison?: boolean;
}

export interface FilterableAttributesFeatures {
  facetSearch?: boolean;
  filter?: FilterFeatures;
}

export interface FilterableAttributesPatterns {
  attributePatterns: AttributePatterns;
  features?: FilterableAttributesFeatures;
}

export type FilterableAttributesRule = string | FilterableAttributesPatterns;

export interface GetLogs {
  /** Lets you specify which parts of the code you want to inspect and is formatted like that: code_part=log_level,code_part=log_level
- If the `code_part` is missing, then the `log_level` will be applied to everything.
- If the `log_level` is missing, then the `code_part` will be selected in `info` log level. */
  target: string;
  mode: LogMode;
  /** A boolean to indicate if you want to profile the memory as well. This is only useful while using the `profile` mode.
Be cautious, though; it slows down the engine a lot. */
  profileMemory: boolean;
}

export interface HealthResponse {
  /** The status of the instance. */
  status: HealthStatus;
}

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthStatus = {
  available: 'available',
} as const;

export type HitsInfoOneOf = {
  /** @minimum 0 */
  hitsPerPage: number;
  /** @minimum 0 */
  page: number;
  /** @minimum 0 */
  totalPages: number;
  /** @minimum 0 */
  totalHits: number;
};

export type HitsInfoOneOfTwo = {
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  estimatedTotalHits: number;
};

export type HitsInfo = HitsInfoOneOf | HitsInfoOneOfTwo;

export interface HybridQuery {
  semanticRatio?: number;
  embedder: string;
}

/**
 * The primary key of the index
 */
export type IndexCreateRequestPrimaryKey = string | null;

export interface IndexCreateRequest {
  /** The name of the index */
  uid: IndexUid;
  /** The primary key of the index */
  primaryKey?: IndexCreateRequestPrimaryKey;
}

/**
 * Number of embeddings in the index
 * @minimum 0
 */
export type IndexStatsNumberOfEmbeddings = number | null;

/**
 * Number of embedded documents in the index
 * @minimum 0
 */
export type IndexStatsNumberOfEmbeddedDocuments = number | null;

/**
 * Association of every field name with the number of times it occurs in the documents.
 */
export type IndexStatsFieldDistribution = {[key: string]: number};

/**
 * Stats of an `Index`, as known to the `stats` route.
 */
export interface IndexStats {
  /**
   * Number of documents in the index
   * @minimum 0
   */
  numberOfDocuments: number;
  /**
   * Size of the documents database, in bytes.
   * @minimum 0
   */
  rawDocumentDbSize: number;
  /**
   * Average size of a document in the documents database.
   * @minimum 0
   */
  avgDocumentSize: number;
  /** Whether or not the index is currently ingesting document */
  isIndexing: boolean;
  /**
   * Number of embeddings in the index
   * @minimum 0
   */
  numberOfEmbeddings?: IndexStatsNumberOfEmbeddings;
  /**
   * Number of embedded documents in the index
   * @minimum 0
   */
  numberOfEmbeddedDocuments?: IndexStatsNumberOfEmbeddedDocuments;
  /** Association of every field name with the number of times it occurs in the documents. */
  fieldDistribution: IndexStatsFieldDistribution;
}

export interface IndexSwap {
  indexes: [string, string];
}

/**
 * An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400
bytes long
 */
export type IndexUid = string;

/**
 * Custom primaryKey for documents
 */
export type IndexViewPrimaryKey = string | null;

export interface IndexView {
  /** Unique identifier for the index */
  uid: string;
  /** An `RFC 3339` format for date/time/duration. */
  createdAt: string;
  /** An `RFC 3339` format for date/time/duration. */
  updatedAt: string;
  /** Custom primaryKey for documents */
  primaryKey?: IndexViewPrimaryKey;
}

/**
 * The name of the API Key if any
 */
export type KeyViewName = string | null;

/**
 * The description of the API Key if any
 */
export type KeyViewDescription = string | null;

/**
 * The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore.
 */
export type KeyViewExpiresAt = string | null;

export interface KeyView {
  /** The name of the API Key if any */
  name?: KeyViewName;
  /** The description of the API Key if any */
  description?: KeyViewDescription;
  /** The actual API Key you can send to Meilisearch */
  key: string;
  /** The `Uuid` specified while creating the key or autogenerated by Meilisearch. */
  uid: string;
  /** The actions accessible with this key. */
  actions: Action[];
  /** The indexes accessible with this key. */
  indexes: string[];
  /** The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore. */
  expiresAt?: KeyViewExpiresAt;
  /** The date of creation of this API Key. */
  readonly createdAt: string;
  /** The date of the last update made on this key. */
  readonly updatedAt: string;
}

/**
 * The type of the task.
 */
export type Kind = typeof Kind[keyof typeof Kind];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Kind = {
  documentAdditionOrUpdate: 'documentAdditionOrUpdate',
  documentEdition: 'documentEdition',
  documentDeletion: 'documentDeletion',
  settingsUpdate: 'settingsUpdate',
  indexCreation: 'indexCreation',
  indexDeletion: 'indexDeletion',
  indexUpdate: 'indexUpdate',
  indexSwap: 'indexSwap',
  taskCancelation: 'taskCancelation',
  taskDeletion: 'taskDeletion',
  dumpCreation: 'dumpCreation',
  snapshotCreation: 'snapshotCreation',
  upgradeDatabase: 'upgradeDatabase',
} as const;

export type Locale = typeof Locale[keyof typeof Locale];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Locale = {
  af: 'af',
  ak: 'ak',
  am: 'am',
  ar: 'ar',
  az: 'az',
  be: 'be',
  bn: 'bn',
  bg: 'bg',
  ca: 'ca',
  cs: 'cs',
  da: 'da',
  de: 'de',
  el: 'el',
  en: 'en',
  eo: 'eo',
  et: 'et',
  fi: 'fi',
  fr: 'fr',
  gu: 'gu',
  he: 'he',
  hi: 'hi',
  hr: 'hr',
  hu: 'hu',
  hy: 'hy',
  id: 'id',
  it: 'it',
  jv: 'jv',
  ja: 'ja',
  kn: 'kn',
  ka: 'ka',
  km: 'km',
  ko: 'ko',
  la: 'la',
  lv: 'lv',
  lt: 'lt',
  ml: 'ml',
  mr: 'mr',
  mk: 'mk',
  my: 'my',
  ne: 'ne',
  nl: 'nl',
  nb: 'nb',
  or: 'or',
  pa: 'pa',
  fa: 'fa',
  pl: 'pl',
  pt: 'pt',
  ro: 'ro',
  ru: 'ru',
  si: 'si',
  sk: 'sk',
  sl: 'sl',
  sn: 'sn',
  es: 'es',
  sr: 'sr',
  sv: 'sv',
  ta: 'ta',
  te: 'te',
  tl: 'tl',
  th: 'th',
  tk: 'tk',
  tr: 'tr',
  uk: 'uk',
  ur: 'ur',
  uz: 'uz',
  vi: 'vi',
  yi: 'yi',
  zh: 'zh',
  zu: 'zu',
  afr: 'afr',
  aka: 'aka',
  amh: 'amh',
  ara: 'ara',
  aze: 'aze',
  bel: 'bel',
  ben: 'ben',
  bul: 'bul',
  cat: 'cat',
  ces: 'ces',
  dan: 'dan',
  deu: 'deu',
  ell: 'ell',
  eng: 'eng',
  epo: 'epo',
  est: 'est',
  fin: 'fin',
  fra: 'fra',
  guj: 'guj',
  heb: 'heb',
  hin: 'hin',
  hrv: 'hrv',
  hun: 'hun',
  hye: 'hye',
  ind: 'ind',
  ita: 'ita',
  jav: 'jav',
  jpn: 'jpn',
  kan: 'kan',
  kat: 'kat',
  khm: 'khm',
  kor: 'kor',
  lat: 'lat',
  lav: 'lav',
  lit: 'lit',
  mal: 'mal',
  mar: 'mar',
  mkd: 'mkd',
  mya: 'mya',
  nep: 'nep',
  nld: 'nld',
  nob: 'nob',
  ori: 'ori',
  pan: 'pan',
  pes: 'pes',
  pol: 'pol',
  por: 'por',
  ron: 'ron',
  rus: 'rus',
  sin: 'sin',
  slk: 'slk',
  slv: 'slv',
  sna: 'sna',
  spa: 'spa',
  srp: 'srp',
  swe: 'swe',
  tam: 'tam',
  tel: 'tel',
  tgl: 'tgl',
  tha: 'tha',
  tuk: 'tuk',
  tur: 'tur',
  ukr: 'ukr',
  urd: 'urd',
  uzb: 'uzb',
  vie: 'vie',
  yid: 'yid',
  zho: 'zho',
  zul: 'zul',
  cmn: 'cmn',
} as const;

export interface LocalizedAttributesRuleView {
  attributePatterns: AttributePatterns;
  locales: Locale[];
}

export type LogMode = typeof LogMode[keyof typeof LogMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogMode = {
  human: 'human',
  json: 'json',
  profile: 'profile',
} as const;

/**
 * This is unfortunately a duplication of the struct in <meilisearch/src/search/mod.rs>.
The reason why it is duplicated is because milli cannot depend on meilisearch. It would be cyclic imports.
 */
export type MatchingStrategy = typeof MatchingStrategy[keyof typeof MatchingStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MatchingStrategy = {
  last: 'last',
  all: 'all',
  frequency: 'frequency',
} as const;

/**
 * @minimum 0
 */
export type MergeFacetsMaxValuesPerFacet = number | null;

export interface MergeFacets {
  /** @minimum 0 */
  maxValuesPerFacet?: MergeFacetsMaxValuesPerFacet;
}

/**
 * @minimum 0
 */
export type MinWordSizeTyposSettingOneTypo = number | null;

/**
 * @minimum 0
 */
export type MinWordSizeTyposSettingTwoTypos = number | null;

export interface MinWordSizeTyposSetting {
  /** @minimum 0 */
  oneTypo?: MinWordSizeTyposSettingOneTypo;
  /** @minimum 0 */
  twoTypos?: MinWordSizeTyposSettingTwoTypos;
}

export type NetworkRemotesAnyOf = {[key: string]: Remote};

export type NetworkRemotes = NetworkRemotesAnyOf | null;

export type NetworkSelf = string | null;

export interface Network {
  remotes?: NetworkRemotes;
  self?: NetworkSelf;
}

export type OverridePooling = typeof OverridePooling[keyof typeof OverridePooling];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OverridePooling = {
  useModel: 'useModel',
  forceCls: 'forceCls',
  forceMean: 'forceMean',
} as const;

/**
 * @minimum 0
 */
export type PaginationSettingsMaxTotalHits = number | null;

export interface PaginationSettings {
  /** @minimum 0 */
  maxTotalHits?: PaginationSettingsMaxTotalHits;
}

/**
 * Custom primaryKey for documents
 */
export type PaginationViewIndexViewResultsItemPrimaryKey = string | null;

export type PaginationViewIndexViewResultsItem = {
  /** Unique identifier for the index */
  uid: string;
  /** An `RFC 3339` format for date/time/duration. */
  createdAt: string;
  /** An `RFC 3339` format for date/time/duration. */
  updatedAt: string;
  /** Custom primaryKey for documents */
  primaryKey?: PaginationViewIndexViewResultsItemPrimaryKey;
};

export interface PaginationViewIndexView {
  results: PaginationViewIndexViewResultsItem[];
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  total: number;
}

/**
 * The name of the API Key if any
 */
export type PaginationViewKeyViewResultsItemName = string | null;

/**
 * The description of the API Key if any
 */
export type PaginationViewKeyViewResultsItemDescription = string | null;

/**
 * The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore.
 */
export type PaginationViewKeyViewResultsItemExpiresAt = string | null;

export type PaginationViewKeyViewResultsItem = {
  /** The name of the API Key if any */
  name?: PaginationViewKeyViewResultsItemName;
  /** The description of the API Key if any */
  description?: PaginationViewKeyViewResultsItemDescription;
  /** The actual API Key you can send to Meilisearch */
  key: string;
  /** The `Uuid` specified while creating the key or autogenerated by Meilisearch. */
  uid: string;
  /** The actions accessible with this key. */
  actions: Action[];
  /** The indexes accessible with this key. */
  indexes: string[];
  /** The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore. */
  expiresAt?: PaginationViewKeyViewResultsItemExpiresAt;
  /** The date of creation of this API Key. */
  readonly createdAt: string;
  /** The date of the last update made on this key. */
  readonly updatedAt: string;
};

export interface PaginationViewKeyView {
  results: PaginationViewKeyViewResultsItem[];
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  total: number;
}

export interface PaginationViewValue {
  results: unknown[];
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  total: number;
}

export type PatchApiKeyDescription = string | null;

export type PatchApiKeyName = string | null;

export interface PatchApiKey {
  description?: PatchApiKeyDescription;
  name?: PatchApiKeyName;
}

export type PrefixSearchSettings = typeof PrefixSearchSettings[keyof typeof PrefixSearchSettings];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PrefixSearchSettings = {
  indexingTime: 'indexingTime',
  disabled: 'disabled',
} as const;

export interface ProgressStepView {
  currentStep: string;
  /** @minimum 0 */
  finished: number;
  /** @minimum 0 */
  total: number;
}

export interface ProgressView {
  steps: ProgressStepView[];
  percentage: number;
}

export type ProximityPrecisionView = typeof ProximityPrecisionView[keyof typeof ProximityPrecisionView];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProximityPrecisionView = {
  byWord: 'byWord',
  byAttribute: 'byAttribute',
} as const;

/**
 * Sorted by the increasing value of the field specified.
 */
export type RankingRuleViewOneOf = {
  /** Sorted by the increasing value of the field specified. */
  Asc: string;
};

/**
 * Sorted by the decreasing value of the field specified.
 */
export type RankingRuleViewOneOfTwo = {
  /** Sorted by the decreasing value of the field specified. */
  Desc: string;
};

export type RankingRuleView = 'Words' | 'Typo' | 'Proximity' | 'Attribute' | 'Sort' | 'Exactness' | RankingRuleViewOneOf | RankingRuleViewOneOfTwo;

export type RankingScoreThreshold = number;

export type RemoteUrl = string | null;

export type RemoteSearchApiKey = string | null;

export interface Remote {
  url?: RemoteUrl;
  searchApiKey?: RemoteSearchApiKey;
}

export interface ResponseError {
  /** The error message. */
  message: string;
  /** The error code. */
  code: Code;
  /** The error type. */
  type: ErrorType;
  /** A link to the documentation about this specific error. */
  link: string;
}

export type RuntimeTogglableFeaturesMetrics = boolean | null;

export type RuntimeTogglableFeaturesLogsRoute = boolean | null;

export type RuntimeTogglableFeaturesEditDocumentsByFunction = boolean | null;

export type RuntimeTogglableFeaturesContainsFilter = boolean | null;

export type RuntimeTogglableFeaturesNetwork = boolean | null;

export type RuntimeTogglableFeaturesGetTaskDocumentsRoute = boolean | null;

export type RuntimeTogglableFeaturesCompositeEmbedders = boolean | null;

export type RuntimeTogglableFeaturesChatCompletions = boolean | null;

export interface RuntimeTogglableFeatures {
  metrics?: RuntimeTogglableFeaturesMetrics;
  logsRoute?: RuntimeTogglableFeaturesLogsRoute;
  editDocumentsByFunction?: RuntimeTogglableFeaturesEditDocumentsByFunction;
  containsFilter?: RuntimeTogglableFeaturesContainsFilter;
  network?: RuntimeTogglableFeaturesNetwork;
  getTaskDocumentsRoute?: RuntimeTogglableFeaturesGetTaskDocumentsRoute;
  compositeEmbedders?: RuntimeTogglableFeaturesCompositeEmbedders;
  chatCompletions?: RuntimeTogglableFeaturesChatCompletions;
}

export type _SearchHitFormatted = { [key: string]: unknown };

export type _SearchHitMatchesPosition = null | BTreeMap;

export type _SearchHitRankingScore = number | null;

export type _SearchHitRankingScoreDetailsAnyOf = {[key: string]: unknown};

export type _SearchHitRankingScoreDetails = _SearchHitRankingScoreDetailsAnyOf | null;

export interface SearchHit {
  _formatted?: _SearchHitFormatted;
  _matchesPosition?: _SearchHitMatchesPosition;
  _rankingScore?: _SearchHitRankingScore;
  _rankingScoreDetails?: _SearchHitRankingScoreDetails;
  [key: string]: unknown;
}

export type SearchQueryQ = string | null;

export type SearchQueryVector = number[] | null;

export type SearchQueryHybrid = null | HybridQuery;

/**
 * @minimum 0
 */
export type SearchQueryPage = number | null;

/**
 * @minimum 0
 */
export type SearchQueryHitsPerPage = number | null;

export type SearchQueryAttributesToRetrieve = string[] | null;

export type SearchQueryAttributesToCrop = string[] | null;

export type SearchQueryAttributesToHighlight = string[] | null;

export type SearchQuerySort = string[] | null;

export type SearchQueryDistinct = string | null;

export type SearchQueryFacets = string[] | null;

export type SearchQueryAttributesToSearchOn = string[] | null;

export type SearchQueryRankingScoreThreshold = null | RankingScoreThreshold;

export type SearchQueryLocales = Locale[] | null;

export interface SearchQuery {
  q?: SearchQueryQ;
  vector?: SearchQueryVector;
  hybrid?: SearchQueryHybrid;
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  limit: number;
  /** @minimum 0 */
  page?: SearchQueryPage;
  /** @minimum 0 */
  hits_per_page?: SearchQueryHitsPerPage;
  attributes_to_retrieve?: SearchQueryAttributesToRetrieve;
  retrieve_vectors: boolean;
  attributes_to_crop?: SearchQueryAttributesToCrop;
  /** @minimum 0 */
  crop_length: number;
  attributes_to_highlight?: SearchQueryAttributesToHighlight;
  show_matches_position: boolean;
  show_ranking_score: boolean;
  show_ranking_score_details: boolean;
  filter?: unknown;
  sort?: SearchQuerySort;
  distinct?: SearchQueryDistinct;
  facets?: SearchQueryFacets;
  highlight_pre_tag: string;
  highlight_post_tag: string;
  crop_marker: string;
  matching_strategy: MatchingStrategy;
  attributes_to_search_on?: SearchQueryAttributesToSearchOn;
  ranking_score_threshold?: SearchQueryRankingScoreThreshold;
  locales?: SearchQueryLocales;
}

export type SearchQueryWithIndexQ = string | null;

export type SearchQueryWithIndexVector = number[] | null;

export type SearchQueryWithIndexHybrid = null | HybridQuery;

/**
 * @minimum 0
 */
export type SearchQueryWithIndexOffset = number | null;

/**
 * @minimum 0
 */
export type SearchQueryWithIndexLimit = number | null;

/**
 * @minimum 0
 */
export type SearchQueryWithIndexPage = number | null;

/**
 * @minimum 0
 */
export type SearchQueryWithIndexHitsPerPage = number | null;

export type SearchQueryWithIndexAttributesToRetrieve = string[] | null;

export type SearchQueryWithIndexAttributesToCrop = string[] | null;

export type SearchQueryWithIndexAttributesToHighlight = string[] | null;

export type SearchQueryWithIndexSort = string[] | null;

export type SearchQueryWithIndexDistinct = string | null;

export type SearchQueryWithIndexFacets = string[] | null;

export type SearchQueryWithIndexAttributesToSearchOn = string[] | null;

export type SearchQueryWithIndexRankingScoreThreshold = null | RankingScoreThreshold;

export type SearchQueryWithIndexLocales = Locale[] | null;

export type SearchQueryWithIndexFederationOptions = null | FederationOptions;

/**
 * A `SearchQuery` + an index UID and optional FederationOptions.
 */
export interface SearchQueryWithIndex {
  indexUid: IndexUid;
  q?: SearchQueryWithIndexQ;
  vector?: SearchQueryWithIndexVector;
  hybrid?: SearchQueryWithIndexHybrid;
  /** @minimum 0 */
  offset?: SearchQueryWithIndexOffset;
  /** @minimum 0 */
  limit?: SearchQueryWithIndexLimit;
  /** @minimum 0 */
  page?: SearchQueryWithIndexPage;
  /** @minimum 0 */
  hitsPerPage?: SearchQueryWithIndexHitsPerPage;
  attributesToRetrieve?: SearchQueryWithIndexAttributesToRetrieve;
  retrieveVectors: boolean;
  attributesToCrop?: SearchQueryWithIndexAttributesToCrop;
  /** @minimum 0 */
  cropLength: number;
  attributesToHighlight?: SearchQueryWithIndexAttributesToHighlight;
  showRankingScore: boolean;
  showRankingScoreDetails: boolean;
  showMatchesPosition: boolean;
  filter?: unknown;
  sort?: SearchQueryWithIndexSort;
  distinct?: SearchQueryWithIndexDistinct;
  facets?: SearchQueryWithIndexFacets;
  highlightPreTag: string;
  highlightPostTag: string;
  cropMarker: string;
  matchingStrategy: MatchingStrategy;
  attributesToSearchOn?: SearchQueryWithIndexAttributesToSearchOn;
  rankingScoreThreshold?: SearchQueryWithIndexRankingScoreThreshold;
  locales?: SearchQueryWithIndexLocales;
  federationOptions?: SearchQueryWithIndexFederationOptions;
}

export type SearchResultAllOfFacetDistributionAnyOf = {[key: string]: unknown};

export type SearchResultAllOfFacetDistribution = SearchResultAllOfFacetDistributionAnyOf | null;

export type SearchResultAllOfFacetStatsAnyOf = {[key: string]: FacetStats};

export type SearchResultAllOfFacetStats = SearchResultAllOfFacetStatsAnyOf | null;

/**
 * @minimum 0
 */
export type SearchResultAllOfSemanticHitCount = number | null;

export type SearchResultAllOf = {
  hits: SearchHit[];
  query: string;
  /** @minimum 0 */
  processingTimeMs: number;
  facetDistribution?: SearchResultAllOfFacetDistribution;
  facetStats?: SearchResultAllOfFacetStats;
  /** @minimum 0 */
  semanticHitCount?: SearchResultAllOfSemanticHitCount;
};

export type SearchResult = HitsInfo & SearchResultAllOf;

export type SearchResultWithIndexAllOf = {
  indexUid: string;
};

export type SearchResultWithIndex = SearchResult & SearchResultWithIndexAllOf;

export interface SearchResults {
  results: SearchResultWithIndex[];
}

export type SettingEmbeddingSettingsInnerOneOfSource = null | EmbedderSource;

/**
 * The name of the model to use.

# Mandatory

- This parameter is mandatory for source `ollama`

# Availability

- This parameter is available for sources `openAi`, `huggingFace`, `ollama`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings.

# Defaults

- For source `openAi`, defaults to `text-embedding-3-small`
- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`
 */
export type SettingEmbeddingSettingsInnerOneOfModel = string | null;

/**
 * The revision (commit SHA1) of the model to use.

If unspecified, Meilisearch picks the latest revision of the model.

# Availability

- This parameter is available for source `huggingFace`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings

# Defaults

- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`
- Otherwise, defaults to `null`
 */
export type SettingEmbeddingSettingsInnerOneOfRevision = string | null;

export type SettingEmbeddingSettingsInnerOneOfPooling = null | OverridePooling;

/**
 * The API key to pass to the remote embedder while making requests.

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.
- For other sources, no bearer token is sent if this parameter is not set.

# Note

- This setting is partially hidden when returned by the settings
 */
export type SettingEmbeddingSettingsInnerOneOfApiKey = string | null;

/**
 * The expected dimensions of the embeddings produced by this embedder.

# Mandatory

- This parameter is mandatory for source `userProvided`

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`

# üîÑ Reindexing

- üèóÔ∏è When the source is `openAi`, changing the value of this parameter always regenerates embeddings
- üå± For other sources, changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the dimensions is the maximum allowed by the model.
- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text.
 */
export type SettingEmbeddingSettingsInnerOneOfDimensions = string | null;

/**
 * Whether to binary quantize the embeddings of this embedder.

Binary quantized embeddings are smaller than regular embeddings, which improves
disk usage and retrieval speed, at the cost of relevancy.

# Availability

- This parameter is available for all embedders

# üîÑ Reindexing

- üèóÔ∏è When set to `true`, embeddings are not regenerated, but they are binary quantized, which takes time.

# Defaults

- Defaults to `false`

# Note

As binary quantization is a destructive operation, it is not possible to disable again this setting after
first enabling it. If you are unsure of whether the performance-relevancy tradeoff is right for you,
we recommend to use this parameter on a test index first.
 */
export type SettingEmbeddingSettingsInnerOneOfBinaryQuantized = boolean | null;

/**
 * A liquid template used to render documents to a text that can be embedded.

Meillisearch interpolates the template for each document and sends the resulting text to the embedder.
The embedder then generates document vectors based on this text.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest

# üîÑ Reindexing

- üèóÔ∏è When modified, embeddings are regenerated for documents whose rendering through the template produces a different text.
 */
export type SettingEmbeddingSettingsInnerOneOfDocumentTemplate = boolean | null;

/**
 * Rendered texts are truncated to this size.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`

# üîÑ Reindexing

- üèóÔ∏è When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.
- üå± When decreased, embeddings are never regenerated

# Default

- Defaults to 400
 * @minimum 0
 */
export type SettingEmbeddingSettingsInnerOneOfDocumentTemplateMaxBytes = number | null;

/**
 * URL to reach the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `openAi`, `ollama` and `rest`

# üîÑ Reindexing

- üå± When modified for source `openAi`, embeddings are never regenerated
- üèóÔ∏è When modified for sources `ollama` and `rest`, embeddings are always regenerated
 */
export type SettingEmbeddingSettingsInnerOneOfUrl = string | null;

/**
 * Additional headers to send to the remote embedder.

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings
 */
export type SettingEmbeddingSettingsInnerOneOfHeadersAnyOf = {[key: string]: string};

/**
 * Additional headers to send to the remote embedder.

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings
 */
export type SettingEmbeddingSettingsInnerOneOfHeaders = SettingEmbeddingSettingsInnerOneOfHeadersAnyOf | null;

export type SettingEmbeddingSettingsInnerOneOfSearchEmbedder = null | SubEmbeddingSettings;

export type SettingEmbeddingSettingsInnerOneOfIndexingEmbedder = null | SubEmbeddingSettings;

export type SettingEmbeddingSettingsInnerOneOfDistribution = null | DistributionShift;

export type SettingEmbeddingSettingsInnerOneOf = {
  source?: SettingEmbeddingSettingsInnerOneOfSource;
  /** The name of the model to use.

# Mandatory

- This parameter is mandatory for source `ollama`

# Availability

- This parameter is available for sources `openAi`, `huggingFace`, `ollama`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings.

# Defaults

- For source `openAi`, defaults to `text-embedding-3-small`
- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5` */
  model?: SettingEmbeddingSettingsInnerOneOfModel;
  /** The revision (commit SHA1) of the model to use.

If unspecified, Meilisearch picks the latest revision of the model.

# Availability

- This parameter is available for source `huggingFace`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings

# Defaults

- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`
- Otherwise, defaults to `null` */
  revision?: SettingEmbeddingSettingsInnerOneOfRevision;
  pooling?: SettingEmbeddingSettingsInnerOneOfPooling;
  /** The API key to pass to the remote embedder while making requests.

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.
- For other sources, no bearer token is sent if this parameter is not set.

# Note

- This setting is partially hidden when returned by the settings */
  apiKey?: SettingEmbeddingSettingsInnerOneOfApiKey;
  /** The expected dimensions of the embeddings produced by this embedder.

# Mandatory

- This parameter is mandatory for source `userProvided`

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`

# üîÑ Reindexing

- üèóÔ∏è When the source is `openAi`, changing the value of this parameter always regenerates embeddings
- üå± For other sources, changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the dimensions is the maximum allowed by the model.
- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text. */
  dimensions?: SettingEmbeddingSettingsInnerOneOfDimensions;
  /** Whether to binary quantize the embeddings of this embedder.

Binary quantized embeddings are smaller than regular embeddings, which improves
disk usage and retrieval speed, at the cost of relevancy.

# Availability

- This parameter is available for all embedders

# üîÑ Reindexing

- üèóÔ∏è When set to `true`, embeddings are not regenerated, but they are binary quantized, which takes time.

# Defaults

- Defaults to `false`

# Note

As binary quantization is a destructive operation, it is not possible to disable again this setting after
first enabling it. If you are unsure of whether the performance-relevancy tradeoff is right for you,
we recommend to use this parameter on a test index first. */
  binaryQuantized?: SettingEmbeddingSettingsInnerOneOfBinaryQuantized;
  /** A liquid template used to render documents to a text that can be embedded.

Meillisearch interpolates the template for each document and sends the resulting text to the embedder.
The embedder then generates document vectors based on this text.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest

# üîÑ Reindexing

- üèóÔ∏è When modified, embeddings are regenerated for documents whose rendering through the template produces a different text. */
  documentTemplate?: SettingEmbeddingSettingsInnerOneOfDocumentTemplate;
  /**
   * Rendered texts are truncated to this size.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`

# üîÑ Reindexing

- üèóÔ∏è When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.
- üå± When decreased, embeddings are never regenerated

# Default

- Defaults to 400
   * @minimum 0
   */
  documentTemplateMaxBytes?: SettingEmbeddingSettingsInnerOneOfDocumentTemplateMaxBytes;
  /** URL to reach the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `openAi`, `ollama` and `rest`

# üîÑ Reindexing

- üå± When modified for source `openAi`, embeddings are never regenerated
- üèóÔ∏è When modified for sources `ollama` and `rest`, embeddings are always regenerated */
  url?: SettingEmbeddingSettingsInnerOneOfUrl;
  /** Template request to send to the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings */
  request?: unknown;
  /** Template response indicating how to find the embeddings in the response from the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings */
  response?: unknown;
  /** Additional headers to send to the remote embedder.

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings */
  headers?: SettingEmbeddingSettingsInnerOneOfHeaders;
  searchEmbedder?: SettingEmbeddingSettingsInnerOneOfSearchEmbedder;
  indexingEmbedder?: SettingEmbeddingSettingsInnerOneOfIndexingEmbedder;
  distribution?: SettingEmbeddingSettingsInnerOneOfDistribution;
};

export type SettingEmbeddingSettingsInner = null | SettingEmbeddingSettingsInnerOneOf;

/**
 * "Technical" type that is required due to utoipa.

We did not find a way to implement [`utoipa::ToSchema`] for the [`Setting`] enum,
but most types can use the `value_type` macro parameter to workaround that issue.

However that type is used in the settings route, including through the macro that auto-generate
all the settings route, so we can't remap the `value_type`.
 */
export interface SettingEmbeddingSettings {
  inner?: SettingEmbeddingSettingsInner;
}

/**
 * Fields displayed in the returned documents.
 */
export type SettingsCheckedDisplayedAttributes = string[] | null;

/**
 * Fields in which to search for matching query words sorted by order of importance.
 */
export type SettingsCheckedSearchableAttributes = string[] | null;

/**
 * Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).
 */
export type SettingsCheckedFilterableAttributes = FilterableAttributesRule[] | null;

/**
 * Attributes to use when sorting search results.
 */
export type SettingsCheckedSortableAttributes = string[] | null;

/**
 * List of ranking rules sorted by order of importance. The order is customizable.
[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).
 */
export type SettingsCheckedRankingRules = string[] | null;

/**
 * List of words ignored when present in search queries.
 */
export type SettingsCheckedStopWords = string[] | null;

/**
 * List of characters not delimiting where one term begins and ends.
 */
export type SettingsCheckedNonSeparatorTokens = string[] | null;

/**
 * List of characters delimiting where one term begins and ends.
 */
export type SettingsCheckedSeparatorTokens = string[] | null;

/**
 * List of strings Meilisearch should parse as a single term.
 */
export type SettingsCheckedDictionary = string[] | null;

/**
 * List of associated words treated similarly. A word associated to an array of word as synonyms.
 */
export type SettingsCheckedSynonymsAnyOf = {[key: string]: string[]};

/**
 * List of associated words treated similarly. A word associated to an array of word as synonyms.
 */
export type SettingsCheckedSynonyms = SettingsCheckedSynonymsAnyOf | null;

/**
 * Search returns documents with distinct (different) values of the given field.
 */
export type SettingsCheckedDistinctAttribute = string | null;

/**
 * Precision level when calculating the proximity ranking rule.
 */
export type SettingsCheckedProximityPrecision = string | null;

export type SettingsCheckedTypoTolerance = null | TypoSettings;

export type SettingsCheckedFaceting = null | FacetingSettings;

export type SettingsCheckedPagination = null | PaginationSettings;

/**
 * Embedder required for performing semantic search queries.
 */
export type SettingsCheckedEmbeddersAnyOf = {[key: string]: SettingEmbeddingSettings};

/**
 * Embedder required for performing semantic search queries.
 */
export type SettingsCheckedEmbedders = SettingsCheckedEmbeddersAnyOf | null;

/**
 * Maximum duration of a search query.
 * @minimum 0
 */
export type SettingsCheckedSearchCutoffMs = number | null;

export type SettingsCheckedLocalizedAttributes = LocalizedAttributesRuleView[] | null;

export type SettingsCheckedFacetSearch = boolean | null;

export type SettingsCheckedPrefixSearch = null | PrefixSearchSettings;

export type SettingsCheckedChat = null | ChatSettings;

/**
 * Holds all the settings for an index. `T` can either be `Checked` if they represents settings
whose validity is guaranteed, or `Unchecked` if they need to be validated. In the later case, a
call to `check` will return a `Settings<Checked>` from a `Settings<Unchecked>`.
 */
export interface SettingsChecked {
  /** Fields displayed in the returned documents. */
  displayedAttributes?: SettingsCheckedDisplayedAttributes;
  /** Fields in which to search for matching query words sorted by order of importance. */
  searchableAttributes?: SettingsCheckedSearchableAttributes;
  /** Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters). */
  filterableAttributes?: SettingsCheckedFilterableAttributes;
  /** Attributes to use when sorting search results. */
  sortableAttributes?: SettingsCheckedSortableAttributes;
  /** List of ranking rules sorted by order of importance. The order is customizable.
[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy). */
  rankingRules?: SettingsCheckedRankingRules;
  /** List of words ignored when present in search queries. */
  stopWords?: SettingsCheckedStopWords;
  /** List of characters not delimiting where one term begins and ends. */
  nonSeparatorTokens?: SettingsCheckedNonSeparatorTokens;
  /** List of characters delimiting where one term begins and ends. */
  separatorTokens?: SettingsCheckedSeparatorTokens;
  /** List of strings Meilisearch should parse as a single term. */
  dictionary?: SettingsCheckedDictionary;
  /** List of associated words treated similarly. A word associated to an array of word as synonyms. */
  synonyms?: SettingsCheckedSynonyms;
  /** Search returns documents with distinct (different) values of the given field. */
  distinctAttribute?: SettingsCheckedDistinctAttribute;
  /** Precision level when calculating the proximity ranking rule. */
  proximityPrecision?: SettingsCheckedProximityPrecision;
  typoTolerance?: SettingsCheckedTypoTolerance;
  faceting?: SettingsCheckedFaceting;
  pagination?: SettingsCheckedPagination;
  /** Embedder required for performing semantic search queries. */
  embedders?: SettingsCheckedEmbedders;
  /**
   * Maximum duration of a search query.
   * @minimum 0
   */
  searchCutoffMs?: SettingsCheckedSearchCutoffMs;
  localizedAttributes?: SettingsCheckedLocalizedAttributes;
  facetSearch?: SettingsCheckedFacetSearch;
  prefixSearch?: SettingsCheckedPrefixSearch;
  chat?: SettingsCheckedChat;
}

/**
 * Fields displayed in the returned documents.
 */
export type SettingsUncheckedDisplayedAttributes = string[] | null;

/**
 * Fields in which to search for matching query words sorted by order of importance.
 */
export type SettingsUncheckedSearchableAttributes = string[] | null;

/**
 * Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).
 */
export type SettingsUncheckedFilterableAttributes = FilterableAttributesRule[] | null;

/**
 * Attributes to use when sorting search results.
 */
export type SettingsUncheckedSortableAttributes = string[] | null;

/**
 * List of ranking rules sorted by order of importance. The order is customizable.
[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).
 */
export type SettingsUncheckedRankingRules = string[] | null;

/**
 * List of words ignored when present in search queries.
 */
export type SettingsUncheckedStopWords = string[] | null;

/**
 * List of characters not delimiting where one term begins and ends.
 */
export type SettingsUncheckedNonSeparatorTokens = string[] | null;

/**
 * List of characters delimiting where one term begins and ends.
 */
export type SettingsUncheckedSeparatorTokens = string[] | null;

/**
 * List of strings Meilisearch should parse as a single term.
 */
export type SettingsUncheckedDictionary = string[] | null;

/**
 * List of associated words treated similarly. A word associated to an array of word as synonyms.
 */
export type SettingsUncheckedSynonymsAnyOf = {[key: string]: string[]};

/**
 * List of associated words treated similarly. A word associated to an array of word as synonyms.
 */
export type SettingsUncheckedSynonyms = SettingsUncheckedSynonymsAnyOf | null;

/**
 * Search returns documents with distinct (different) values of the given field.
 */
export type SettingsUncheckedDistinctAttribute = string | null;

/**
 * Precision level when calculating the proximity ranking rule.
 */
export type SettingsUncheckedProximityPrecision = string | null;

export type SettingsUncheckedTypoTolerance = null | TypoSettings;

export type SettingsUncheckedFaceting = null | FacetingSettings;

export type SettingsUncheckedPagination = null | PaginationSettings;

/**
 * Embedder required for performing semantic search queries.
 */
export type SettingsUncheckedEmbeddersAnyOf = {[key: string]: SettingEmbeddingSettings};

/**
 * Embedder required for performing semantic search queries.
 */
export type SettingsUncheckedEmbedders = SettingsUncheckedEmbeddersAnyOf | null;

/**
 * Maximum duration of a search query.
 * @minimum 0
 */
export type SettingsUncheckedSearchCutoffMs = number | null;

export type SettingsUncheckedLocalizedAttributes = LocalizedAttributesRuleView[] | null;

export type SettingsUncheckedFacetSearch = boolean | null;

export type SettingsUncheckedPrefixSearch = null | PrefixSearchSettings;

export type SettingsUncheckedChat = null | ChatSettings;

/**
 * Holds all the settings for an index. `T` can either be `Checked` if they represents settings
whose validity is guaranteed, or `Unchecked` if they need to be validated. In the later case, a
call to `check` will return a `Settings<Checked>` from a `Settings<Unchecked>`.
 */
export interface SettingsUnchecked {
  /** Fields displayed in the returned documents. */
  displayedAttributes?: SettingsUncheckedDisplayedAttributes;
  /** Fields in which to search for matching query words sorted by order of importance. */
  searchableAttributes?: SettingsUncheckedSearchableAttributes;
  /** Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters). */
  filterableAttributes?: SettingsUncheckedFilterableAttributes;
  /** Attributes to use when sorting search results. */
  sortableAttributes?: SettingsUncheckedSortableAttributes;
  /** List of ranking rules sorted by order of importance. The order is customizable.
[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy). */
  rankingRules?: SettingsUncheckedRankingRules;
  /** List of words ignored when present in search queries. */
  stopWords?: SettingsUncheckedStopWords;
  /** List of characters not delimiting where one term begins and ends. */
  nonSeparatorTokens?: SettingsUncheckedNonSeparatorTokens;
  /** List of characters delimiting where one term begins and ends. */
  separatorTokens?: SettingsUncheckedSeparatorTokens;
  /** List of strings Meilisearch should parse as a single term. */
  dictionary?: SettingsUncheckedDictionary;
  /** List of associated words treated similarly. A word associated to an array of word as synonyms. */
  synonyms?: SettingsUncheckedSynonyms;
  /** Search returns documents with distinct (different) values of the given field. */
  distinctAttribute?: SettingsUncheckedDistinctAttribute;
  /** Precision level when calculating the proximity ranking rule. */
  proximityPrecision?: SettingsUncheckedProximityPrecision;
  typoTolerance?: SettingsUncheckedTypoTolerance;
  faceting?: SettingsUncheckedFaceting;
  pagination?: SettingsUncheckedPagination;
  /** Embedder required for performing semantic search queries. */
  embedders?: SettingsUncheckedEmbedders;
  /**
   * Maximum duration of a search query.
   * @minimum 0
   */
  searchCutoffMs?: SettingsUncheckedSearchCutoffMs;
  localizedAttributes?: SettingsUncheckedLocalizedAttributes;
  facetSearch?: SettingsUncheckedFacetSearch;
  prefixSearch?: SettingsUncheckedPrefixSearch;
  chat?: SettingsUncheckedChat;
}

export type SimilarQueryAttributesToRetrieve = string[] | null;

export interface SimilarQuery {
  id: string;
  /** @minimum 0 */
  offset: number;
  /** @minimum 0 */
  limit: number;
  filter?: unknown;
  embedder: string;
  attributes_to_retrieve?: SimilarQueryAttributesToRetrieve;
  retrieve_vectors: boolean;
  show_ranking_score: boolean;
  show_ranking_score_details: boolean;
  ranking_score_threshold: number;
}

export type SimilarResultAllOf = {
  hits: SearchHit[];
  id: string;
  /** @minimum 0 */
  processingTimeMs: number;
};

export type SimilarResult = HitsInfo & SimilarResultAllOf;

/**
 * The date of the last update in the RFC 3339 formats. Can be `null` if no update has ever been processed.
 */
export type StatsLastUpdate = string | null;

/**
 * The stats of every individual index your API key lets you access.
 */
export type StatsIndexes = {[key: string]: IndexStats};

export interface Stats {
  /**
   * The disk space used by the database, in bytes.
   * @minimum 0
   */
  databaseSize: number;
  /**
   * The size of the database, in bytes.
   * @minimum 0
   */
  usedDatabaseSize: number;
  /** The date of the last update in the RFC 3339 formats. Can be `null` if no update has ever been processed. */
  lastUpdate?: StatsLastUpdate;
  /** The stats of every individual index your API key lets you access. */
  indexes: StatsIndexes;
}

/**
 * The status of a task.
 */
export type Status = typeof Status[keyof typeof Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  enqueued: 'enqueued',
  processing: 'processing',
  succeeded: 'succeeded',
  failed: 'failed',
  canceled: 'canceled',
} as const;

export type SubEmbeddingSettingsSource = null | EmbedderSource;

/**
 * The name of the model to use.

# Mandatory

- This parameter is mandatory for source `ollama`

# Availability

- This parameter is available for sources `openAi`, `huggingFace`, `ollama`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings.

# Defaults

- For source `openAi`, defaults to `text-embedding-3-small`
- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`
 */
export type SubEmbeddingSettingsModel = string | null;

/**
 * The revision (commit SHA1) of the model to use.

If unspecified, Meilisearch picks the latest revision of the model.

# Availability

- This parameter is available for source `huggingFace`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings

# Defaults

- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`
- Otherwise, defaults to `null`
 */
export type SubEmbeddingSettingsRevision = string | null;

export type SubEmbeddingSettingsPooling = null | OverridePooling;

/**
 * The API key to pass to the remote embedder while making requests.

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.
- For other sources, no bearer token is sent if this parameter is not set.

# Note

- This setting is partially hidden when returned by the settings
 */
export type SubEmbeddingSettingsApiKey = string | null;

/**
 * The expected dimensions of the embeddings produced by this embedder.

# Mandatory

- This parameter is mandatory for source `userProvided`

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`

# üîÑ Reindexing

- üèóÔ∏è When the source is `openAi`, changing the value of this parameter always regenerates embeddings
- üå± For other sources, changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the dimensions is the maximum allowed by the model.
- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text.
 */
export type SubEmbeddingSettingsDimensions = string | null;

/**
 * A liquid template used to render documents to a text that can be embedded.

Meillisearch interpolates the template for each document and sends the resulting text to the embedder.
The embedder then generates document vectors based on this text.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest

# üîÑ Reindexing

- üèóÔ∏è When modified, embeddings are regenerated for documents whose rendering through the template produces a different text.
 */
export type SubEmbeddingSettingsDocumentTemplate = boolean | null;

/**
 * Rendered texts are truncated to this size.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`

# üîÑ Reindexing

- üèóÔ∏è When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.
- üå± When decreased, embeddings are never regenerated

# Default

- Defaults to 400
 * @minimum 0
 */
export type SubEmbeddingSettingsDocumentTemplateMaxBytes = number | null;

/**
 * URL to reach the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `openAi`, `ollama` and `rest`

# üîÑ Reindexing

- üå± When modified for source `openAi`, embeddings are never regenerated
- üèóÔ∏è When modified for sources `ollama` and `rest`, embeddings are always regenerated
 */
export type SubEmbeddingSettingsUrl = string | null;

/**
 * Additional headers to send to the remote embedder.

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings
 */
export type SubEmbeddingSettingsHeadersAnyOf = {[key: string]: string};

/**
 * Additional headers to send to the remote embedder.

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings
 */
export type SubEmbeddingSettingsHeaders = SubEmbeddingSettingsHeadersAnyOf | null;

export interface SubEmbeddingSettings {
  source?: SubEmbeddingSettingsSource;
  /** The name of the model to use.

# Mandatory

- This parameter is mandatory for source `ollama`

# Availability

- This parameter is available for sources `openAi`, `huggingFace`, `ollama`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings.

# Defaults

- For source `openAi`, defaults to `text-embedding-3-small`
- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5` */
  model?: SubEmbeddingSettingsModel;
  /** The revision (commit SHA1) of the model to use.

If unspecified, Meilisearch picks the latest revision of the model.

# Availability

- This parameter is available for source `huggingFace`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings

# Defaults

- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`
- Otherwise, defaults to `null` */
  revision?: SubEmbeddingSettingsRevision;
  pooling?: SubEmbeddingSettingsPooling;
  /** The API key to pass to the remote embedder while making requests.

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.
- For other sources, no bearer token is sent if this parameter is not set.

# Note

- This setting is partially hidden when returned by the settings */
  apiKey?: SubEmbeddingSettingsApiKey;
  /** The expected dimensions of the embeddings produced by this embedder.

# Mandatory

- This parameter is mandatory for source `userProvided`

# Availability

- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`

# üîÑ Reindexing

- üèóÔ∏è When the source is `openAi`, changing the value of this parameter always regenerates embeddings
- üå± For other sources, changing the value of this parameter never regenerates embeddings

# Defaults

- For source `openAi`, the dimensions is the maximum allowed by the model.
- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text. */
  dimensions?: SubEmbeddingSettingsDimensions;
  /** A liquid template used to render documents to a text that can be embedded.

Meillisearch interpolates the template for each document and sends the resulting text to the embedder.
The embedder then generates document vectors based on this text.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest

# üîÑ Reindexing

- üèóÔ∏è When modified, embeddings are regenerated for documents whose rendering through the template produces a different text. */
  documentTemplate?: SubEmbeddingSettingsDocumentTemplate;
  /**
   * Rendered texts are truncated to this size.

# Availability

- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`

# üîÑ Reindexing

- üèóÔ∏è When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.
- üå± When decreased, embeddings are never regenerated

# Default

- Defaults to 400
   * @minimum 0
   */
  documentTemplateMaxBytes?: SubEmbeddingSettingsDocumentTemplateMaxBytes;
  /** URL to reach the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `openAi`, `ollama` and `rest`

# üîÑ Reindexing

- üå± When modified for source `openAi`, embeddings are never regenerated
- üèóÔ∏è When modified for sources `ollama` and `rest`, embeddings are always regenerated */
  url?: SubEmbeddingSettingsUrl;
  /** Template request to send to the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings */
  request?: unknown;
  /** Template response indicating how to find the embeddings in the response from the remote embedder.

# Mandatory

- This parameter is mandatory for source `rest`

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üèóÔ∏è Changing the value of this parameter always regenerates embeddings */
  response?: unknown;
  /** Additional headers to send to the remote embedder.

# Availability

- This parameter is available for source `rest`

# üîÑ Reindexing

- üå± Changing the value of this parameter never regenerates embeddings */
  headers?: SubEmbeddingSettingsHeaders;
}

/**
 * The index affected by this task. May be `null` if the task is not linked to any index.
 */
export type SummarizedTaskViewIndexUid = string | null;

export interface SummarizedTaskView {
  /**
   * The task unique identifier.
   * @minimum 0
   */
  taskUid: number;
  /** The index affected by this task. May be `null` if the task is not linked to any index. */
  indexUid?: SummarizedTaskViewIndexUid;
  /** The status of the task. */
  status: Status;
  /** The type of the task. */
  type: Kind;
  /** The date on which the task was enqueued. */
  enqueuedAt: string;
}

export interface SwapIndexesPayload {
  /** Array of the two indexUids to be swapped */
  indexes: IndexUid[];
}

/**
 * The unique identifier of the index where this task is operated.
 * @minimum 0
 */
export type TaskViewBatchUid = number | null;

export type TaskViewIndexUid = string | null;

/**
 * The uid of the task that performed the taskCancelation if the task has been canceled.
 * @minimum 0
 */
export type TaskViewCanceledBy = number | null;

export type TaskViewDetails = null | DetailsView;

export type TaskViewError = null | ResponseError;

/**
 * Total elasped time the engine was in processing state expressed as a `ISO-8601` duration format.
 */
export type TaskViewDuration = string | null;

export interface TaskView {
  /**
   * The unique sequential identifier of the task.
   * @minimum 0
   */
  uid: number;
  /**
   * The unique identifier of the index where this task is operated.
   * @minimum 0
   */
  batchUid?: TaskViewBatchUid;
  indexUid?: TaskViewIndexUid;
  status: Status;
  /** The type of the task. */
  type: Kind;
  /**
   * The uid of the task that performed the taskCancelation if the task has been canceled.
   * @minimum 0
   */
  canceledBy?: TaskViewCanceledBy;
  details?: TaskViewDetails;
  error?: TaskViewError;
  /** Total elasped time the engine was in processing state expressed as a `ISO-8601` duration format. */
  duration?: TaskViewDuration;
  /** An `RFC 3339` format for date/time/duration. */
  enqueuedAt: string;
  /** An `RFC 3339` format for date/time/duration. */
  startedAt?: string;
  /** An `RFC 3339` format for date/time/duration. */
  finishedAt?: string;
}

export type TypoSettingsEnabled = boolean | null;

export type TypoSettingsMinWordSizeForTypos = null | MinWordSizeTyposSetting;

export type TypoSettingsDisableOnWords = string[] | null;

export type TypoSettingsDisableOnAttributes = string[] | null;

export type TypoSettingsDisableOnNumbers = boolean | null;

export interface TypoSettings {
  enabled?: TypoSettingsEnabled;
  minWordSizeForTypos?: TypoSettingsMinWordSizeForTypos;
  disableOnWords?: TypoSettingsDisableOnWords;
  disableOnAttributes?: TypoSettingsDisableOnAttributes;
  disableOnNumbers?: TypoSettingsDisableOnNumbers;
}

export interface Unchecked {}

/**
 * The new primary key of the index
 */
export type UpdateIndexRequestPrimaryKey = string | null;

export interface UpdateIndexRequest {
  /** The new primary key of the index */
  primaryKey?: UpdateIndexRequestPrimaryKey;
}

export interface UpdateStderrLogs {
  /** Lets you specify which parts of the code you want to inspect and is formatted like that: code_part=log_level,code_part=log_level
- If the `code_part` is missing, then the `log_level` will be applied to everything.
- If the `log_level` is missing, then the `code_part` will be selected in `info` log level. */
  target: string;
}

export interface VersionResponse {
  /** The commit used to compile this build of Meilisearch. */
  commitSha: string;
  /** The date of this build. */
  commitDate: string;
  /** The version of Meilisearch. */
  pkgVersion: string;
}

/**
 * @minimum 0
 */
export type U32 = number;

export type GetBatchesParams = {
/**
 * Maximum number of results to return.
 * @minimum 0
 */
limit?: number;
/**
 * Fetch the next set of results from the given uid.
 * @minimum 0
 */
from?: number;
/**
 * The order you want to retrieve the objects.
 */
reverse?: boolean;
/**
 * Permits to filter tasks by their batch uid. By default, when the `batchUids` query parameter is not set, all task uids are returned. It's possible to specify several batch uids by separating them with the `,` character.
 * @minimum 0
 */
batchUids?: number;
/**
 * Permits to filter tasks by their uid. By default, when the uids query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.
 */
uids?: number[];
/**
 * Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.
 */
canceledBy?: number[];
/**
 * Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.
 */
types?: string[];
/**
 * Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.
 */
statuses?: Status[];
/**
 * Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.
 */
indexUids?: string[];
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.
 */
afterEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.
 */
beforeEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.
 */
afterStartedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.
 */
beforeStartedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.
 */
afterFinishedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.
 */
beforeFinishedAt?: string;
};

export type ListIndexesParams = {
/**
 * The number of indexes to skip before starting to retrieve anything
 * @minimum 0
 */
offset?: number;
/**
 * The number of indexes to retrieve
 * @minimum 0
 */
limit?: number;
};

export type GetDocumentsParams = {
/**
 * @minimum 0
 */
offset?: number;
/**
 * @minimum 0
 */
limit?: number;
fields?: string[];
retrieveVectors?: boolean;
ids?: string[];
filter?: string;
};

export type UpdateDocumentsParams = {
/**
 * The primary key of the documents. primaryKey is optional. If you want to set the primary key of your index through this route,
it only has to be done the first time you add documents to the index. After which it will be ignored if given.
 */
primaryKey?: string;
/**
 * Customize the csv delimiter when importing CSV documents.
 */
csvDelimiter?: string;
};

export type ReplaceDocumentsParams = {
/**
 * The primary key of the documents. primaryKey is optional. If you want to set the primary key of your index through this route,
it only has to be done the first time you add documents to the index. After which it will be ignored if given.
 */
primaryKey?: string;
/**
 * Customize the csv delimiter when importing CSV documents.
 */
csvDelimiter?: string;
};

export type GetDocumentParams = {
fields?: string[];
retrieveVectors?: boolean;
};

export type SearchWithUrlQueryParams = {
q?: string;
vector: number[];
/**
 * @minimum 0
 */
offset: number;
/**
 * @minimum 0
 */
limit?: number;
/**
 * @minimum 0
 */
page?: number;
/**
 * @minimum 0
 */
hitsPerPage?: number;
attributesToRetrieve: string[];
retrieveVectors: boolean;
attributesToCrop: string[];
/**
 * @minimum 0
 */
cropLength?: number;
attributesToHighlight: string[];
filter?: string;
sort?: string;
distinct?: string;
showMatchesPosition: boolean;
showRankingScore: boolean;
showRankingScoreDetails: boolean;
facets: string[];
highlightPreTag?: string;
highlightPostTag?: string;
cropMarker?: string;
matchingStrategy: MatchingStrategy;
attributesToSearchOn: string[];
hybridEmbedder?: string;
hybridSemanticRatio: number;
rankingScoreThreshold: number;
locales: Locale[];
};

export type Getembedders200 = {[key: string]: SettingEmbeddingSettings};

export type DeleteembeddersBody = {[key: string]: SettingEmbeddingSettings};

export type PatchembeddersBody = {[key: string]: SettingEmbeddingSettings};

export type Getsynonyms200 = {[key: string]: string[]};

export type PutsynonymsBody = {[key: string]: string[]};

export type DeletesynonymsBody = {[key: string]: string[]};

export type SimilarGetParams = {
id: string;
/**
 * @minimum 0
 */
offset: number;
/**
 * @minimum 0
 */
limit?: number;
attributes_to_retrieve: string[];
retrieve_vectors: boolean;
filter?: string;
show_ranking_score: boolean;
show_ranking_score_details: boolean;
ranking_score_threshold?: number;
embedder: string;
};

export type ListApiKeysParams = {
/**
 * @minimum 0
 */
offset: number;
/**
 * @minimum 0
 */
limit?: number;
};

export type GetTasksParams = {
/**
 * Maximum number of results to return.
 * @minimum 0
 */
limit?: number;
/**
 * Fetch the next set of results from the given uid.
 * @minimum 0
 */
from?: number;
/**
 * The order you want to retrieve the objects.
 */
reverse?: boolean;
/**
 * Permits to filter tasks by their batch uid. By default, when the `batchUids` query parameter is not set, all task uids are returned. It's possible to specify several batch uids by separating them with the `,` character.
 * @minimum 0
 */
batchUids?: number;
/**
 * Permits to filter tasks by their uid. By default, when the uids query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.
 */
uids?: number[];
/**
 * Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.
 */
canceledBy?: number[];
/**
 * Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.
 */
types?: string[];
/**
 * Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.
 */
statuses?: Status[];
/**
 * Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.
 */
indexUids?: string[];
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.
 */
afterEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.
 */
beforeEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.
 */
afterStartedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.
 */
beforeStartedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.
 */
afterFinishedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.
 */
beforeFinishedAt?: string;
};

export type DeleteTasksParams = {
/**
 * Permits to filter tasks by their uid. By default, when the `uids` query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.
 */
uids?: number[];
/**
 * Lets you filter tasks by their `batchUid`.
 */
batchUids?: number[];
/**
 * Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.
 */
canceledBy?: number[];
/**
 * Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.
 */
types?: Kind[];
/**
 * Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.
 */
statuses?: Status[];
/**
 * Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.
 */
indexUids?: string[];
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.
 */
afterEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.
 */
beforeEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.
 */
afterStartedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.
 */
beforeStartedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.
 */
afterFinishedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.
 */
beforeFinishedAt?: string;
};

export type CancelTasksParams = {
/**
 * Permits to filter tasks by their uid. By default, when the `uids` query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.
 */
uids?: number[];
/**
 * Lets you filter tasks by their `batchUid`.
 */
batchUids?: number[];
/**
 * Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.
 */
canceledBy?: number[];
/**
 * Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.
 */
types?: Kind[];
/**
 * Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.
 */
statuses?: Status[];
/**
 * Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.
 */
indexUids?: string[];
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.
 */
afterEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.
 */
beforeEnqueuedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.
 */
afterStartedAt?: string;
/**
 * Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.
 */
beforeStartedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.
 */
afterFinishedAt?: string;
/**
 * Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.
 */
beforeFinishedAt?: string;
};


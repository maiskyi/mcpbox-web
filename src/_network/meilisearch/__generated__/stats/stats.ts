/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * meilisearch
 * Meilisearch HTTP server
 * OpenAPI spec version: 1.15.2
 */
import {
  useInfiniteQuery,
  useQuery
} from '@tanstack/react-query';
import type {
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  IndexStats,
  ResponseError,
  Stats
} from '../api.schemas';

import { customInstance } from '../../utils/orval/orval.utils';
import { customQueryOptions } from '../../utils/orval/orval.utils';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get the stats of an index.
 * @summary Get stats of index
 */
export const getIndexStats = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<IndexStats>(
      {url: `/indexes/${indexUid}/stats`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndexStatsQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/stats`] as const;
    }

    
export const useGetIndexStatsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getIndexStats>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getIndexStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndexStatsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndexStats>>> = ({ signal }) => getIndexStats(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getIndexStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndexStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getIndexStats>>>
export type GetIndexStatsInfiniteQueryError = ResponseError


/**
 * @summary Get stats of index
 */

export function useGetIndexStatsInfinite<TData = Awaited<ReturnType<typeof getIndexStats>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getIndexStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetIndexStatsInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetIndexStatsQueryOptions = <TData = Awaited<ReturnType<typeof getIndexStats>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndexStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndexStatsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndexStats>>> = ({ signal }) => getIndexStats(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getIndexStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndexStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndexStats>>>
export type GetIndexStatsQueryError = ResponseError


/**
 * @summary Get stats of index
 */

export function useGetIndexStats<TData = Awaited<ReturnType<typeof getIndexStats>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndexStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetIndexStatsQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve metrics on the engine. See https://www.meilisearch.com/docs/learn/experimental/metrics
Currently, [the feature is experimental](https://www.meilisearch.com/docs/learn/experimental/overview)
which means it must be enabled.
 * @summary Get prometheus metrics
 */
export const getMetrics = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/metrics`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMetricsQueryKey = () => {
    return [`/metrics`] as const;
    }

    
export const useGetMetricsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getMetrics>>, TError = ResponseError>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetrics>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetricsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetrics>>> = ({ signal }) => getMetrics(requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetrics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMetricsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMetrics>>>
export type GetMetricsInfiniteQueryError = ResponseError


/**
 * @summary Get prometheus metrics
 */

export function useGetMetricsInfinite<TData = Awaited<ReturnType<typeof getMetrics>>, TError = ResponseError>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetrics>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetMetricsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getMetrics>>, TError = ResponseError>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMetrics>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetricsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetrics>>> = ({ signal }) => getMetrics(requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getMetrics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getMetrics>>>
export type GetMetricsQueryError = ResponseError


/**
 * @summary Get prometheus metrics
 */

export function useGetMetrics<TData = Awaited<ReturnType<typeof getMetrics>>, TError = ResponseError>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMetrics>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetMetricsQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get stats of all indexes.
 * @summary Get stats of all indexes.
 */
export const getStats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Stats>(
      {url: `/stats`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStatsQueryKey = () => {
    return [`/stats`] as const;
    }

    
export const useGetStatsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getStats>>, TError = ResponseError>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStats>>> = ({ signal }) => getStats(requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStats>>>
export type GetStatsInfiniteQueryError = ResponseError


/**
 * @summary Get stats of all indexes.
 */

export function useGetStatsInfinite<TData = Awaited<ReturnType<typeof getStats>>, TError = ResponseError>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetStatsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetStatsQueryOptions = <TData = Awaited<ReturnType<typeof getStats>>, TError = ResponseError>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStats>>> = ({ signal }) => getStats(requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getStats>>>
export type GetStatsQueryError = ResponseError


/**
 * @summary Get stats of all indexes.
 */

export function useGetStats<TData = Awaited<ReturnType<typeof getStats>>, TError = ResponseError>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetStatsQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




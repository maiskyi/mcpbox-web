/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * meilisearch
 * Meilisearch HTTP server
 * OpenAPI spec version: 1.15.2
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ChatSettings,
  DeleteembeddersBody,
  DeletesynonymsBody,
  FacetingSettings,
  FilterableAttributesRule,
  Getembedders200,
  Getsynonyms200,
  LocalizedAttributesRuleView,
  PaginationSettings,
  PatchembeddersBody,
  PrefixSearchSettings,
  ProximityPrecisionView,
  PutsynonymsBody,
  RankingRuleView,
  ResponseError,
  SettingsUnchecked,
  SummarizedTaskView,
  TypoSettings
} from '../api.schemas';

import { customInstance } from '../../utils/orval/orval.utils';
import { customQueryOptions } from '../../utils/orval/orval.utils';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * This route allows you to retrieve, configure, or reset all of an index's settings at once.
 * @summary All settings
 */
export const getAll = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SettingsUnchecked>(
      {url: `/indexes/${indexUid}/settings`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings`] as const;
    }

    
export const useGetAllInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getAll>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>
export type GetAllInfiniteQueryError = ResponseError


/**
 * @summary All settings
 */

export function useGetAllInfinite<TData = Awaited<ReturnType<typeof getAll>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetAllInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetAllQueryOptions = <TData = Awaited<ReturnType<typeof getAll>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>
export type GetAllQueryError = ResponseError


/**
 * @summary All settings
 */

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetAllQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Reset all the settings of an index to their default value.
 * @summary Reset settings
 */
export const deleteAll = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAllMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAll>>, TError,{indexUid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAll>>, TError,{indexUid: string}, TContext> => {

const mutationKey = ['deleteAll'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAll>>, {indexUid: string}> = (props) => {
          const {indexUid} = props ?? {};

          return  deleteAll(indexUid,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAllMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAll>>>
    
    export type DeleteAllMutationError = ResponseError

    /**
 * @summary Reset settings
 */
export const useDeleteAll = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAll>>, TError,{indexUid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAll>>,
        TError,
        {indexUid: string},
        TContext
      > => {

      const mutationOptions = getDeleteAllMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update the settings of an index.
Passing null to an index setting will reset it to its default value.
Updates in the settings route are partial. This means that any parameters not provided in the body will be left unchanged.
If the provided index does not exist, it will be created.
 * @summary Update settings
 */
export const updateAll = (
    indexUid: string,
    settingsUnchecked: SettingsUnchecked,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: settingsUnchecked
    },
      options);
    }
  


export const getUpdateAllMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAll>>, TError,{indexUid: string;data: SettingsUnchecked}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAll>>, TError,{indexUid: string;data: SettingsUnchecked}, TContext> => {

const mutationKey = ['updateAll'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAll>>, {indexUid: string;data: SettingsUnchecked}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  updateAll(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAllMutationResult = NonNullable<Awaited<ReturnType<typeof updateAll>>>
    export type UpdateAllMutationBody = SettingsUnchecked
    export type UpdateAllMutationError = ResponseError

    /**
 * @summary Update settings
 */
export const useUpdateAll = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAll>>, TError,{indexUid: string;data: SettingsUnchecked}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateAll>>,
        TError,
        {indexUid: string;data: SettingsUnchecked},
        TContext
      > => {

      const mutationOptions = getUpdateAllMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined chat
 * @summary Get chat
 */
export const getchat = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ChatSettings>(
      {url: `/indexes/${indexUid}/settings/chat`, method: 'GET', signal
    },
      options);
    }
  

export const getGetchatQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/chat`] as const;
    }

    
export const useGetchatInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getchat>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getchat>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetchatQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getchat>>> = ({ signal }) => getchat(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getchat>>, TError, TData> & { queryKey: QueryKey }
}

export type GetchatInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getchat>>>
export type GetchatInfiniteQueryError = ResponseError


/**
 * @summary Get chat
 */

export function useGetchatInfinite<TData = Awaited<ReturnType<typeof getchat>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getchat>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetchatInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetchatQueryOptions = <TData = Awaited<ReturnType<typeof getchat>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getchat>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetchatQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getchat>>> = ({ signal }) => getchat(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getchat>>, TError, TData> & { queryKey: QueryKey }
}

export type GetchatQueryResult = NonNullable<Awaited<ReturnType<typeof getchat>>>
export type GetchatQueryError = ResponseError


/**
 * @summary Get chat
 */

export function useGetchat<TData = Awaited<ReturnType<typeof getchat>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getchat>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetchatQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined chat
 * @summary Update chat
 */
export const putchat = (
    indexUid: string,
    chatSettings: ChatSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/chat`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: chatSettings
    },
      options);
    }
  


export const getPutchatMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putchat>>, TError,{indexUid: string;data: ChatSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putchat>>, TError,{indexUid: string;data: ChatSettings}, TContext> => {

const mutationKey = ['putchat'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putchat>>, {indexUid: string;data: ChatSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putchat(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutchatMutationResult = NonNullable<Awaited<ReturnType<typeof putchat>>>
    export type PutchatMutationBody = ChatSettings
    export type PutchatMutationError = ResponseError

    /**
 * @summary Update chat
 */
export const usePutchat = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putchat>>, TError,{indexUid: string;data: ChatSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putchat>>,
        TError,
        {indexUid: string;data: ChatSettings},
        TContext
      > => {

      const mutationOptions = getPutchatMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's chat to its default value
 * @summary Reset chat
 */
export const deletechat = (
    indexUid: string,
    chatSettings: ChatSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/chat`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: chatSettings
    },
      options);
    }
  


export const getDeletechatMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletechat>>, TError,{indexUid: string;data: ChatSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletechat>>, TError,{indexUid: string;data: ChatSettings}, TContext> => {

const mutationKey = ['deletechat'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletechat>>, {indexUid: string;data: ChatSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletechat(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletechatMutationResult = NonNullable<Awaited<ReturnType<typeof deletechat>>>
    export type DeletechatMutationBody = ChatSettings
    export type DeletechatMutationError = ResponseError

    /**
 * @summary Reset chat
 */
export const useDeletechat = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletechat>>, TError,{indexUid: string;data: ChatSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletechat>>,
        TError,
        {indexUid: string;data: ChatSettings},
        TContext
      > => {

      const mutationOptions = getDeletechatMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined dictionary
 * @summary Get dictionary
 */
export const getdictionary = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/dictionary`, method: 'GET', signal
    },
      options);
    }
  

export const getGetdictionaryQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/dictionary`] as const;
    }

    
export const useGetdictionaryInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getdictionary>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdictionary>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetdictionaryQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getdictionary>>> = ({ signal }) => getdictionary(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdictionary>>, TError, TData> & { queryKey: QueryKey }
}

export type GetdictionaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getdictionary>>>
export type GetdictionaryInfiniteQueryError = ResponseError


/**
 * @summary Get dictionary
 */

export function useGetdictionaryInfinite<TData = Awaited<ReturnType<typeof getdictionary>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdictionary>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetdictionaryInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetdictionaryQueryOptions = <TData = Awaited<ReturnType<typeof getdictionary>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getdictionary>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetdictionaryQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getdictionary>>> = ({ signal }) => getdictionary(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getdictionary>>, TError, TData> & { queryKey: QueryKey }
}

export type GetdictionaryQueryResult = NonNullable<Awaited<ReturnType<typeof getdictionary>>>
export type GetdictionaryQueryError = ResponseError


/**
 * @summary Get dictionary
 */

export function useGetdictionary<TData = Awaited<ReturnType<typeof getdictionary>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getdictionary>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetdictionaryQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined dictionary
 * @summary Update dictionary
 */
export const putdictionary = (
    indexUid: string,
    putdictionaryBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/dictionary`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putdictionaryBody
    },
      options);
    }
  


export const getPutdictionaryMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putdictionary>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putdictionary>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putdictionary'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putdictionary>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putdictionary(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutdictionaryMutationResult = NonNullable<Awaited<ReturnType<typeof putdictionary>>>
    export type PutdictionaryMutationBody = string[]
    export type PutdictionaryMutationError = ResponseError

    /**
 * @summary Update dictionary
 */
export const usePutdictionary = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putdictionary>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putdictionary>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutdictionaryMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's dictionary to its default value
 * @summary Reset dictionary
 */
export const deletedictionary = (
    indexUid: string,
    deletedictionaryBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/dictionary`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletedictionaryBody
    },
      options);
    }
  


export const getDeletedictionaryMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletedictionary>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletedictionary>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deletedictionary'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletedictionary>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletedictionary(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletedictionaryMutationResult = NonNullable<Awaited<ReturnType<typeof deletedictionary>>>
    export type DeletedictionaryMutationBody = string[]
    export type DeletedictionaryMutationError = ResponseError

    /**
 * @summary Reset dictionary
 */
export const useDeletedictionary = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletedictionary>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletedictionary>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeletedictionaryMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined displayedAttributes
 * @summary Get displayedAttributes
 */
export const getdisplayedAttributes = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/displayed-attributes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetdisplayedAttributesQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/displayed-attributes`] as const;
    }

    
export const useGetdisplayedAttributesInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getdisplayedAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdisplayedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetdisplayedAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getdisplayedAttributes>>> = ({ signal }) => getdisplayedAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdisplayedAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetdisplayedAttributesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getdisplayedAttributes>>>
export type GetdisplayedAttributesInfiniteQueryError = ResponseError


/**
 * @summary Get displayedAttributes
 */

export function useGetdisplayedAttributesInfinite<TData = Awaited<ReturnType<typeof getdisplayedAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdisplayedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetdisplayedAttributesInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetdisplayedAttributesQueryOptions = <TData = Awaited<ReturnType<typeof getdisplayedAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getdisplayedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetdisplayedAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getdisplayedAttributes>>> = ({ signal }) => getdisplayedAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getdisplayedAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetdisplayedAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof getdisplayedAttributes>>>
export type GetdisplayedAttributesQueryError = ResponseError


/**
 * @summary Get displayedAttributes
 */

export function useGetdisplayedAttributes<TData = Awaited<ReturnType<typeof getdisplayedAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getdisplayedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetdisplayedAttributesQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined displayedAttributes
 * @summary Update displayedAttributes
 */
export const putdisplayedAttributes = (
    indexUid: string,
    putdisplayedAttributesBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/displayed-attributes`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putdisplayedAttributesBody
    },
      options);
    }
  


export const getPutdisplayedAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putdisplayedAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putdisplayedAttributes>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putdisplayedAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putdisplayedAttributes>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putdisplayedAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutdisplayedAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof putdisplayedAttributes>>>
    export type PutdisplayedAttributesMutationBody = string[]
    export type PutdisplayedAttributesMutationError = ResponseError

    /**
 * @summary Update displayedAttributes
 */
export const usePutdisplayedAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putdisplayedAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putdisplayedAttributes>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutdisplayedAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's displayedAttributes to its default value
 * @summary Reset displayedAttributes
 */
export const deletedisplayedAttributes = (
    indexUid: string,
    deletedisplayedAttributesBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/displayed-attributes`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletedisplayedAttributesBody
    },
      options);
    }
  


export const getDeletedisplayedAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletedisplayedAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletedisplayedAttributes>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deletedisplayedAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletedisplayedAttributes>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletedisplayedAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletedisplayedAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof deletedisplayedAttributes>>>
    export type DeletedisplayedAttributesMutationBody = string[]
    export type DeletedisplayedAttributesMutationError = ResponseError

    /**
 * @summary Reset displayedAttributes
 */
export const useDeletedisplayedAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletedisplayedAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletedisplayedAttributes>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeletedisplayedAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined distinctAttribute
 * @summary Get distinctAttribute
 */
export const getdistinctAttribute = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/indexes/${indexUid}/settings/distinct-attribute`, method: 'GET', signal
    },
      options);
    }
  

export const getGetdistinctAttributeQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/distinct-attribute`] as const;
    }

    
export const useGetdistinctAttributeInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getdistinctAttribute>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdistinctAttribute>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetdistinctAttributeQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getdistinctAttribute>>> = ({ signal }) => getdistinctAttribute(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdistinctAttribute>>, TError, TData> & { queryKey: QueryKey }
}

export type GetdistinctAttributeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getdistinctAttribute>>>
export type GetdistinctAttributeInfiniteQueryError = ResponseError


/**
 * @summary Get distinctAttribute
 */

export function useGetdistinctAttributeInfinite<TData = Awaited<ReturnType<typeof getdistinctAttribute>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getdistinctAttribute>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetdistinctAttributeInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetdistinctAttributeQueryOptions = <TData = Awaited<ReturnType<typeof getdistinctAttribute>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getdistinctAttribute>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetdistinctAttributeQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getdistinctAttribute>>> = ({ signal }) => getdistinctAttribute(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getdistinctAttribute>>, TError, TData> & { queryKey: QueryKey }
}

export type GetdistinctAttributeQueryResult = NonNullable<Awaited<ReturnType<typeof getdistinctAttribute>>>
export type GetdistinctAttributeQueryError = ResponseError


/**
 * @summary Get distinctAttribute
 */

export function useGetdistinctAttribute<TData = Awaited<ReturnType<typeof getdistinctAttribute>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getdistinctAttribute>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetdistinctAttributeQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined distinctAttribute
 * @summary Update distinctAttribute
 */
export const putdistinctAttribute = (
    indexUid: string,
    putdistinctAttributeBody: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/distinct-attribute`, method: 'PUT',
      headers: {'Content-Type': 'text/plain', },
      data: putdistinctAttributeBody
    },
      options);
    }
  


export const getPutdistinctAttributeMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putdistinctAttribute>>, TError,{indexUid: string;data: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putdistinctAttribute>>, TError,{indexUid: string;data: string}, TContext> => {

const mutationKey = ['putdistinctAttribute'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putdistinctAttribute>>, {indexUid: string;data: string}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putdistinctAttribute(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutdistinctAttributeMutationResult = NonNullable<Awaited<ReturnType<typeof putdistinctAttribute>>>
    export type PutdistinctAttributeMutationBody = string
    export type PutdistinctAttributeMutationError = ResponseError

    /**
 * @summary Update distinctAttribute
 */
export const usePutdistinctAttribute = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putdistinctAttribute>>, TError,{indexUid: string;data: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putdistinctAttribute>>,
        TError,
        {indexUid: string;data: string},
        TContext
      > => {

      const mutationOptions = getPutdistinctAttributeMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's distinctAttribute to its default value
 * @summary Reset distinctAttribute
 */
export const deletedistinctAttribute = (
    indexUid: string,
    deletedistinctAttributeBody: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/distinct-attribute`, method: 'DELETE',
      headers: {'Content-Type': 'text/plain', },
      data: deletedistinctAttributeBody
    },
      options);
    }
  


export const getDeletedistinctAttributeMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletedistinctAttribute>>, TError,{indexUid: string;data: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletedistinctAttribute>>, TError,{indexUid: string;data: string}, TContext> => {

const mutationKey = ['deletedistinctAttribute'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletedistinctAttribute>>, {indexUid: string;data: string}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletedistinctAttribute(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletedistinctAttributeMutationResult = NonNullable<Awaited<ReturnType<typeof deletedistinctAttribute>>>
    export type DeletedistinctAttributeMutationBody = string
    export type DeletedistinctAttributeMutationError = ResponseError

    /**
 * @summary Reset distinctAttribute
 */
export const useDeletedistinctAttribute = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletedistinctAttribute>>, TError,{indexUid: string;data: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletedistinctAttribute>>,
        TError,
        {indexUid: string;data: string},
        TContext
      > => {

      const mutationOptions = getDeletedistinctAttributeMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined embedders
 * @summary Get embedders
 */
export const getembedders = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Getembedders200>(
      {url: `/indexes/${indexUid}/settings/embedders`, method: 'GET', signal
    },
      options);
    }
  

export const getGetembeddersQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/embedders`] as const;
    }

    
export const useGetembeddersInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getembedders>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getembedders>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetembeddersQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getembedders>>> = ({ signal }) => getembedders(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getembedders>>, TError, TData> & { queryKey: QueryKey }
}

export type GetembeddersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getembedders>>>
export type GetembeddersInfiniteQueryError = ResponseError


/**
 * @summary Get embedders
 */

export function useGetembeddersInfinite<TData = Awaited<ReturnType<typeof getembedders>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getembedders>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetembeddersInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetembeddersQueryOptions = <TData = Awaited<ReturnType<typeof getembedders>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getembedders>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetembeddersQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getembedders>>> = ({ signal }) => getembedders(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getembedders>>, TError, TData> & { queryKey: QueryKey }
}

export type GetembeddersQueryResult = NonNullable<Awaited<ReturnType<typeof getembedders>>>
export type GetembeddersQueryError = ResponseError


/**
 * @summary Get embedders
 */

export function useGetembedders<TData = Awaited<ReturnType<typeof getembedders>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getembedders>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetembeddersQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Reset an index's embedders to its default value
 * @summary Reset embedders
 */
export const deleteembedders = (
    indexUid: string,
    deleteembeddersBody: DeleteembeddersBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/embedders`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteembeddersBody
    },
      options);
    }
  


export const getDeleteembeddersMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteembedders>>, TError,{indexUid: string;data: DeleteembeddersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteembedders>>, TError,{indexUid: string;data: DeleteembeddersBody}, TContext> => {

const mutationKey = ['deleteembedders'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteembedders>>, {indexUid: string;data: DeleteembeddersBody}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleteembedders(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteembeddersMutationResult = NonNullable<Awaited<ReturnType<typeof deleteembedders>>>
    export type DeleteembeddersMutationBody = DeleteembeddersBody
    export type DeleteembeddersMutationError = ResponseError

    /**
 * @summary Reset embedders
 */
export const useDeleteembedders = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteembedders>>, TError,{indexUid: string;data: DeleteembeddersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteembedders>>,
        TError,
        {indexUid: string;data: DeleteembeddersBody},
        TContext
      > => {

      const mutationOptions = getDeleteembeddersMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update an index's user defined embedders
 * @summary Update embedders
 */
export const patchembedders = (
    indexUid: string,
    patchembeddersBody: PatchembeddersBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/embedders`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchembeddersBody
    },
      options);
    }
  


export const getPatchembeddersMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchembedders>>, TError,{indexUid: string;data: PatchembeddersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchembedders>>, TError,{indexUid: string;data: PatchembeddersBody}, TContext> => {

const mutationKey = ['patchembedders'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchembedders>>, {indexUid: string;data: PatchembeddersBody}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  patchembedders(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchembeddersMutationResult = NonNullable<Awaited<ReturnType<typeof patchembedders>>>
    export type PatchembeddersMutationBody = PatchembeddersBody
    export type PatchembeddersMutationError = ResponseError

    /**
 * @summary Update embedders
 */
export const usePatchembedders = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchembedders>>, TError,{indexUid: string;data: PatchembeddersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchembedders>>,
        TError,
        {indexUid: string;data: PatchembeddersBody},
        TContext
      > => {

      const mutationOptions = getPatchembeddersMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined facetSearch
 * @summary Get facetSearch
 */
export const getfacetSearch = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<boolean>(
      {url: `/indexes/${indexUid}/settings/facet-search`, method: 'GET', signal
    },
      options);
    }
  

export const getGetfacetSearchQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/facet-search`] as const;
    }

    
export const useGetfacetSearchInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getfacetSearch>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfacetSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetfacetSearchQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getfacetSearch>>> = ({ signal }) => getfacetSearch(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfacetSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetfacetSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getfacetSearch>>>
export type GetfacetSearchInfiniteQueryError = ResponseError


/**
 * @summary Get facetSearch
 */

export function useGetfacetSearchInfinite<TData = Awaited<ReturnType<typeof getfacetSearch>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfacetSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetfacetSearchInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetfacetSearchQueryOptions = <TData = Awaited<ReturnType<typeof getfacetSearch>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getfacetSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetfacetSearchQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getfacetSearch>>> = ({ signal }) => getfacetSearch(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getfacetSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetfacetSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getfacetSearch>>>
export type GetfacetSearchQueryError = ResponseError


/**
 * @summary Get facetSearch
 */

export function useGetfacetSearch<TData = Awaited<ReturnType<typeof getfacetSearch>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getfacetSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetfacetSearchQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined facetSearch
 * @summary Update facetSearch
 */
export const putfacetSearch = (
    indexUid: string,
    boolean: boolean,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/facet-search`, method: 'PUT',
      headers: {'Content-Type': 'text/plain', },
      data: boolean
    },
      options);
    }
  


export const getPutfacetSearchMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putfacetSearch>>, TError,{indexUid: string;data: boolean}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putfacetSearch>>, TError,{indexUid: string;data: boolean}, TContext> => {

const mutationKey = ['putfacetSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putfacetSearch>>, {indexUid: string;data: boolean}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putfacetSearch(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutfacetSearchMutationResult = NonNullable<Awaited<ReturnType<typeof putfacetSearch>>>
    export type PutfacetSearchMutationBody = boolean
    export type PutfacetSearchMutationError = ResponseError

    /**
 * @summary Update facetSearch
 */
export const usePutfacetSearch = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putfacetSearch>>, TError,{indexUid: string;data: boolean}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putfacetSearch>>,
        TError,
        {indexUid: string;data: boolean},
        TContext
      > => {

      const mutationOptions = getPutfacetSearchMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's facetSearch to its default value
 * @summary Reset facetSearch
 */
export const deletefacetSearch = (
    indexUid: string,
    boolean: boolean,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/facet-search`, method: 'DELETE',
      headers: {'Content-Type': 'text/plain', },
      data: boolean
    },
      options);
    }
  


export const getDeletefacetSearchMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletefacetSearch>>, TError,{indexUid: string;data: boolean}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletefacetSearch>>, TError,{indexUid: string;data: boolean}, TContext> => {

const mutationKey = ['deletefacetSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletefacetSearch>>, {indexUid: string;data: boolean}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletefacetSearch(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletefacetSearchMutationResult = NonNullable<Awaited<ReturnType<typeof deletefacetSearch>>>
    export type DeletefacetSearchMutationBody = boolean
    export type DeletefacetSearchMutationError = ResponseError

    /**
 * @summary Reset facetSearch
 */
export const useDeletefacetSearch = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletefacetSearch>>, TError,{indexUid: string;data: boolean}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletefacetSearch>>,
        TError,
        {indexUid: string;data: boolean},
        TContext
      > => {

      const mutationOptions = getDeletefacetSearchMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined faceting
 * @summary Get faceting
 */
export const getfaceting = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FacetingSettings>(
      {url: `/indexes/${indexUid}/settings/faceting`, method: 'GET', signal
    },
      options);
    }
  

export const getGetfacetingQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/faceting`] as const;
    }

    
export const useGetfacetingInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getfaceting>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfaceting>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetfacetingQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getfaceting>>> = ({ signal }) => getfaceting(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfaceting>>, TError, TData> & { queryKey: QueryKey }
}

export type GetfacetingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getfaceting>>>
export type GetfacetingInfiniteQueryError = ResponseError


/**
 * @summary Get faceting
 */

export function useGetfacetingInfinite<TData = Awaited<ReturnType<typeof getfaceting>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfaceting>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetfacetingInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetfacetingQueryOptions = <TData = Awaited<ReturnType<typeof getfaceting>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getfaceting>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetfacetingQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getfaceting>>> = ({ signal }) => getfaceting(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getfaceting>>, TError, TData> & { queryKey: QueryKey }
}

export type GetfacetingQueryResult = NonNullable<Awaited<ReturnType<typeof getfaceting>>>
export type GetfacetingQueryError = ResponseError


/**
 * @summary Get faceting
 */

export function useGetfaceting<TData = Awaited<ReturnType<typeof getfaceting>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getfaceting>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetfacetingQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Reset an index's faceting to its default value
 * @summary Reset faceting
 */
export const deletefaceting = (
    indexUid: string,
    facetingSettings: FacetingSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/faceting`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: facetingSettings
    },
      options);
    }
  


export const getDeletefacetingMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletefaceting>>, TError,{indexUid: string;data: FacetingSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletefaceting>>, TError,{indexUid: string;data: FacetingSettings}, TContext> => {

const mutationKey = ['deletefaceting'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletefaceting>>, {indexUid: string;data: FacetingSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletefaceting(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletefacetingMutationResult = NonNullable<Awaited<ReturnType<typeof deletefaceting>>>
    export type DeletefacetingMutationBody = FacetingSettings
    export type DeletefacetingMutationError = ResponseError

    /**
 * @summary Reset faceting
 */
export const useDeletefaceting = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletefaceting>>, TError,{indexUid: string;data: FacetingSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletefaceting>>,
        TError,
        {indexUid: string;data: FacetingSettings},
        TContext
      > => {

      const mutationOptions = getDeletefacetingMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update an index's user defined faceting
 * @summary Update faceting
 */
export const patchfaceting = (
    indexUid: string,
    facetingSettings: FacetingSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/faceting`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: facetingSettings
    },
      options);
    }
  


export const getPatchfacetingMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchfaceting>>, TError,{indexUid: string;data: FacetingSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchfaceting>>, TError,{indexUid: string;data: FacetingSettings}, TContext> => {

const mutationKey = ['patchfaceting'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchfaceting>>, {indexUid: string;data: FacetingSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  patchfaceting(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchfacetingMutationResult = NonNullable<Awaited<ReturnType<typeof patchfaceting>>>
    export type PatchfacetingMutationBody = FacetingSettings
    export type PatchfacetingMutationError = ResponseError

    /**
 * @summary Update faceting
 */
export const usePatchfaceting = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchfaceting>>, TError,{indexUid: string;data: FacetingSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchfaceting>>,
        TError,
        {indexUid: string;data: FacetingSettings},
        TContext
      > => {

      const mutationOptions = getPatchfacetingMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined filterableAttributes
 * @summary Get filterableAttributes
 */
export const getfilterableAttributes = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FilterableAttributesRule[]>(
      {url: `/indexes/${indexUid}/settings/filterable-attributes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetfilterableAttributesQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/filterable-attributes`] as const;
    }

    
export const useGetfilterableAttributesInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getfilterableAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfilterableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetfilterableAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getfilterableAttributes>>> = ({ signal }) => getfilterableAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfilterableAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetfilterableAttributesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getfilterableAttributes>>>
export type GetfilterableAttributesInfiniteQueryError = ResponseError


/**
 * @summary Get filterableAttributes
 */

export function useGetfilterableAttributesInfinite<TData = Awaited<ReturnType<typeof getfilterableAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getfilterableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetfilterableAttributesInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetfilterableAttributesQueryOptions = <TData = Awaited<ReturnType<typeof getfilterableAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getfilterableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetfilterableAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getfilterableAttributes>>> = ({ signal }) => getfilterableAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getfilterableAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetfilterableAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof getfilterableAttributes>>>
export type GetfilterableAttributesQueryError = ResponseError


/**
 * @summary Get filterableAttributes
 */

export function useGetfilterableAttributes<TData = Awaited<ReturnType<typeof getfilterableAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getfilterableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetfilterableAttributesQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined filterableAttributes
 * @summary Update filterableAttributes
 */
export const putfilterableAttributes = (
    indexUid: string,
    filterableAttributesRule: FilterableAttributesRule[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/filterable-attributes`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: filterableAttributesRule
    },
      options);
    }
  


export const getPutfilterableAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putfilterableAttributes>>, TError,{indexUid: string;data: FilterableAttributesRule[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putfilterableAttributes>>, TError,{indexUid: string;data: FilterableAttributesRule[]}, TContext> => {

const mutationKey = ['putfilterableAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putfilterableAttributes>>, {indexUid: string;data: FilterableAttributesRule[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putfilterableAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutfilterableAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof putfilterableAttributes>>>
    export type PutfilterableAttributesMutationBody = FilterableAttributesRule[]
    export type PutfilterableAttributesMutationError = ResponseError

    /**
 * @summary Update filterableAttributes
 */
export const usePutfilterableAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putfilterableAttributes>>, TError,{indexUid: string;data: FilterableAttributesRule[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putfilterableAttributes>>,
        TError,
        {indexUid: string;data: FilterableAttributesRule[]},
        TContext
      > => {

      const mutationOptions = getPutfilterableAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's filterableAttributes to its default value
 * @summary Reset filterableAttributes
 */
export const deletefilterableAttributes = (
    indexUid: string,
    filterableAttributesRule: FilterableAttributesRule[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/filterable-attributes`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: filterableAttributesRule
    },
      options);
    }
  


export const getDeletefilterableAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletefilterableAttributes>>, TError,{indexUid: string;data: FilterableAttributesRule[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletefilterableAttributes>>, TError,{indexUid: string;data: FilterableAttributesRule[]}, TContext> => {

const mutationKey = ['deletefilterableAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletefilterableAttributes>>, {indexUid: string;data: FilterableAttributesRule[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletefilterableAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletefilterableAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof deletefilterableAttributes>>>
    export type DeletefilterableAttributesMutationBody = FilterableAttributesRule[]
    export type DeletefilterableAttributesMutationError = ResponseError

    /**
 * @summary Reset filterableAttributes
 */
export const useDeletefilterableAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletefilterableAttributes>>, TError,{indexUid: string;data: FilterableAttributesRule[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletefilterableAttributes>>,
        TError,
        {indexUid: string;data: FilterableAttributesRule[]},
        TContext
      > => {

      const mutationOptions = getDeletefilterableAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined localizedAttributes
 * @summary Get localizedAttributes
 */
export const getlocalizedAttributes = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LocalizedAttributesRuleView[]>(
      {url: `/indexes/${indexUid}/settings/localized-attributes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetlocalizedAttributesQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/localized-attributes`] as const;
    }

    
export const useGetlocalizedAttributesInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getlocalizedAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getlocalizedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetlocalizedAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getlocalizedAttributes>>> = ({ signal }) => getlocalizedAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getlocalizedAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetlocalizedAttributesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getlocalizedAttributes>>>
export type GetlocalizedAttributesInfiniteQueryError = ResponseError


/**
 * @summary Get localizedAttributes
 */

export function useGetlocalizedAttributesInfinite<TData = Awaited<ReturnType<typeof getlocalizedAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getlocalizedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetlocalizedAttributesInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetlocalizedAttributesQueryOptions = <TData = Awaited<ReturnType<typeof getlocalizedAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getlocalizedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetlocalizedAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getlocalizedAttributes>>> = ({ signal }) => getlocalizedAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getlocalizedAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetlocalizedAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof getlocalizedAttributes>>>
export type GetlocalizedAttributesQueryError = ResponseError


/**
 * @summary Get localizedAttributes
 */

export function useGetlocalizedAttributes<TData = Awaited<ReturnType<typeof getlocalizedAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getlocalizedAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetlocalizedAttributesQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined localizedAttributes
 * @summary Update localizedAttributes
 */
export const putlocalizedAttributes = (
    indexUid: string,
    localizedAttributesRuleView: LocalizedAttributesRuleView[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/localized-attributes`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: localizedAttributesRuleView
    },
      options);
    }
  


export const getPutlocalizedAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putlocalizedAttributes>>, TError,{indexUid: string;data: LocalizedAttributesRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putlocalizedAttributes>>, TError,{indexUid: string;data: LocalizedAttributesRuleView[]}, TContext> => {

const mutationKey = ['putlocalizedAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putlocalizedAttributes>>, {indexUid: string;data: LocalizedAttributesRuleView[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putlocalizedAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutlocalizedAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof putlocalizedAttributes>>>
    export type PutlocalizedAttributesMutationBody = LocalizedAttributesRuleView[]
    export type PutlocalizedAttributesMutationError = ResponseError

    /**
 * @summary Update localizedAttributes
 */
export const usePutlocalizedAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putlocalizedAttributes>>, TError,{indexUid: string;data: LocalizedAttributesRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putlocalizedAttributes>>,
        TError,
        {indexUid: string;data: LocalizedAttributesRuleView[]},
        TContext
      > => {

      const mutationOptions = getPutlocalizedAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's localizedAttributes to its default value
 * @summary Reset localizedAttributes
 */
export const deletelocalizedAttributes = (
    indexUid: string,
    localizedAttributesRuleView: LocalizedAttributesRuleView[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/localized-attributes`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: localizedAttributesRuleView
    },
      options);
    }
  


export const getDeletelocalizedAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletelocalizedAttributes>>, TError,{indexUid: string;data: LocalizedAttributesRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletelocalizedAttributes>>, TError,{indexUid: string;data: LocalizedAttributesRuleView[]}, TContext> => {

const mutationKey = ['deletelocalizedAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletelocalizedAttributes>>, {indexUid: string;data: LocalizedAttributesRuleView[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletelocalizedAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletelocalizedAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof deletelocalizedAttributes>>>
    export type DeletelocalizedAttributesMutationBody = LocalizedAttributesRuleView[]
    export type DeletelocalizedAttributesMutationError = ResponseError

    /**
 * @summary Reset localizedAttributes
 */
export const useDeletelocalizedAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletelocalizedAttributes>>, TError,{indexUid: string;data: LocalizedAttributesRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletelocalizedAttributes>>,
        TError,
        {indexUid: string;data: LocalizedAttributesRuleView[]},
        TContext
      > => {

      const mutationOptions = getDeletelocalizedAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined nonSeparatorTokens
 * @summary Get nonSeparatorTokens
 */
export const getnonSeparatorTokens = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/non-separator-tokens`, method: 'GET', signal
    },
      options);
    }
  

export const getGetnonSeparatorTokensQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/non-separator-tokens`] as const;
    }

    
export const useGetnonSeparatorTokensInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetnonSeparatorTokensQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getnonSeparatorTokens>>> = ({ signal }) => getnonSeparatorTokens(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type GetnonSeparatorTokensInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getnonSeparatorTokens>>>
export type GetnonSeparatorTokensInfiniteQueryError = ResponseError


/**
 * @summary Get nonSeparatorTokens
 */

export function useGetnonSeparatorTokensInfinite<TData = Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetnonSeparatorTokensInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetnonSeparatorTokensQueryOptions = <TData = Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetnonSeparatorTokensQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getnonSeparatorTokens>>> = ({ signal }) => getnonSeparatorTokens(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type GetnonSeparatorTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getnonSeparatorTokens>>>
export type GetnonSeparatorTokensQueryError = ResponseError


/**
 * @summary Get nonSeparatorTokens
 */

export function useGetnonSeparatorTokens<TData = Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getnonSeparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetnonSeparatorTokensQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined nonSeparatorTokens
 * @summary Update nonSeparatorTokens
 */
export const putnonSeparatorTokens = (
    indexUid: string,
    putnonSeparatorTokensBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/non-separator-tokens`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putnonSeparatorTokensBody
    },
      options);
    }
  


export const getPutnonSeparatorTokensMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putnonSeparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putnonSeparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putnonSeparatorTokens'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putnonSeparatorTokens>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putnonSeparatorTokens(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutnonSeparatorTokensMutationResult = NonNullable<Awaited<ReturnType<typeof putnonSeparatorTokens>>>
    export type PutnonSeparatorTokensMutationBody = string[]
    export type PutnonSeparatorTokensMutationError = ResponseError

    /**
 * @summary Update nonSeparatorTokens
 */
export const usePutnonSeparatorTokens = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putnonSeparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putnonSeparatorTokens>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutnonSeparatorTokensMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's nonSeparatorTokens to its default value
 * @summary Reset nonSeparatorTokens
 */
export const deletenonSeparatorTokens = (
    indexUid: string,
    deletenonSeparatorTokensBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/non-separator-tokens`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletenonSeparatorTokensBody
    },
      options);
    }
  


export const getDeletenonSeparatorTokensMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletenonSeparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletenonSeparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deletenonSeparatorTokens'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletenonSeparatorTokens>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletenonSeparatorTokens(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletenonSeparatorTokensMutationResult = NonNullable<Awaited<ReturnType<typeof deletenonSeparatorTokens>>>
    export type DeletenonSeparatorTokensMutationBody = string[]
    export type DeletenonSeparatorTokensMutationError = ResponseError

    /**
 * @summary Reset nonSeparatorTokens
 */
export const useDeletenonSeparatorTokens = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletenonSeparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletenonSeparatorTokens>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeletenonSeparatorTokensMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined pagination
 * @summary Get pagination
 */
export const getpagination = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginationSettings>(
      {url: `/indexes/${indexUid}/settings/pagination`, method: 'GET', signal
    },
      options);
    }
  

export const getGetpaginationQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/pagination`] as const;
    }

    
export const useGetpaginationInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getpagination>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getpagination>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetpaginationQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getpagination>>> = ({ signal }) => getpagination(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getpagination>>, TError, TData> & { queryKey: QueryKey }
}

export type GetpaginationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getpagination>>>
export type GetpaginationInfiniteQueryError = ResponseError


/**
 * @summary Get pagination
 */

export function useGetpaginationInfinite<TData = Awaited<ReturnType<typeof getpagination>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getpagination>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetpaginationInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetpaginationQueryOptions = <TData = Awaited<ReturnType<typeof getpagination>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getpagination>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetpaginationQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getpagination>>> = ({ signal }) => getpagination(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getpagination>>, TError, TData> & { queryKey: QueryKey }
}

export type GetpaginationQueryResult = NonNullable<Awaited<ReturnType<typeof getpagination>>>
export type GetpaginationQueryError = ResponseError


/**
 * @summary Get pagination
 */

export function useGetpagination<TData = Awaited<ReturnType<typeof getpagination>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getpagination>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetpaginationQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Reset an index's pagination to its default value
 * @summary Reset pagination
 */
export const deletepagination = (
    indexUid: string,
    paginationSettings: PaginationSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/pagination`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: paginationSettings
    },
      options);
    }
  


export const getDeletepaginationMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletepagination>>, TError,{indexUid: string;data: PaginationSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletepagination>>, TError,{indexUid: string;data: PaginationSettings}, TContext> => {

const mutationKey = ['deletepagination'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletepagination>>, {indexUid: string;data: PaginationSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletepagination(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletepaginationMutationResult = NonNullable<Awaited<ReturnType<typeof deletepagination>>>
    export type DeletepaginationMutationBody = PaginationSettings
    export type DeletepaginationMutationError = ResponseError

    /**
 * @summary Reset pagination
 */
export const useDeletepagination = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletepagination>>, TError,{indexUid: string;data: PaginationSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletepagination>>,
        TError,
        {indexUid: string;data: PaginationSettings},
        TContext
      > => {

      const mutationOptions = getDeletepaginationMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update an index's user defined pagination
 * @summary Update pagination
 */
export const patchpagination = (
    indexUid: string,
    paginationSettings: PaginationSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/pagination`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: paginationSettings
    },
      options);
    }
  


export const getPatchpaginationMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchpagination>>, TError,{indexUid: string;data: PaginationSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchpagination>>, TError,{indexUid: string;data: PaginationSettings}, TContext> => {

const mutationKey = ['patchpagination'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchpagination>>, {indexUid: string;data: PaginationSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  patchpagination(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchpaginationMutationResult = NonNullable<Awaited<ReturnType<typeof patchpagination>>>
    export type PatchpaginationMutationBody = PaginationSettings
    export type PatchpaginationMutationError = ResponseError

    /**
 * @summary Update pagination
 */
export const usePatchpagination = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchpagination>>, TError,{indexUid: string;data: PaginationSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchpagination>>,
        TError,
        {indexUid: string;data: PaginationSettings},
        TContext
      > => {

      const mutationOptions = getPatchpaginationMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined prefixSearch
 * @summary Get prefixSearch
 */
export const getprefixSearch = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PrefixSearchSettings>(
      {url: `/indexes/${indexUid}/settings/prefix-search`, method: 'GET', signal
    },
      options);
    }
  

export const getGetprefixSearchQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/prefix-search`] as const;
    }

    
export const useGetprefixSearchInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getprefixSearch>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getprefixSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetprefixSearchQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getprefixSearch>>> = ({ signal }) => getprefixSearch(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getprefixSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetprefixSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getprefixSearch>>>
export type GetprefixSearchInfiniteQueryError = ResponseError


/**
 * @summary Get prefixSearch
 */

export function useGetprefixSearchInfinite<TData = Awaited<ReturnType<typeof getprefixSearch>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getprefixSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetprefixSearchInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetprefixSearchQueryOptions = <TData = Awaited<ReturnType<typeof getprefixSearch>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getprefixSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetprefixSearchQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getprefixSearch>>> = ({ signal }) => getprefixSearch(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getprefixSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetprefixSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getprefixSearch>>>
export type GetprefixSearchQueryError = ResponseError


/**
 * @summary Get prefixSearch
 */

export function useGetprefixSearch<TData = Awaited<ReturnType<typeof getprefixSearch>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getprefixSearch>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetprefixSearchQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined prefixSearch
 * @summary Update prefixSearch
 */
export const putprefixSearch = (
    indexUid: string,
    prefixSearchSettings: PrefixSearchSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/prefix-search`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: prefixSearchSettings
    },
      options);
    }
  


export const getPutprefixSearchMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putprefixSearch>>, TError,{indexUid: string;data: PrefixSearchSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putprefixSearch>>, TError,{indexUid: string;data: PrefixSearchSettings}, TContext> => {

const mutationKey = ['putprefixSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putprefixSearch>>, {indexUid: string;data: PrefixSearchSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putprefixSearch(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutprefixSearchMutationResult = NonNullable<Awaited<ReturnType<typeof putprefixSearch>>>
    export type PutprefixSearchMutationBody = PrefixSearchSettings
    export type PutprefixSearchMutationError = ResponseError

    /**
 * @summary Update prefixSearch
 */
export const usePutprefixSearch = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putprefixSearch>>, TError,{indexUid: string;data: PrefixSearchSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putprefixSearch>>,
        TError,
        {indexUid: string;data: PrefixSearchSettings},
        TContext
      > => {

      const mutationOptions = getPutprefixSearchMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's prefixSearch to its default value
 * @summary Reset prefixSearch
 */
export const deleteprefixSearch = (
    indexUid: string,
    prefixSearchSettings: PrefixSearchSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/prefix-search`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: prefixSearchSettings
    },
      options);
    }
  


export const getDeleteprefixSearchMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteprefixSearch>>, TError,{indexUid: string;data: PrefixSearchSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteprefixSearch>>, TError,{indexUid: string;data: PrefixSearchSettings}, TContext> => {

const mutationKey = ['deleteprefixSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteprefixSearch>>, {indexUid: string;data: PrefixSearchSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleteprefixSearch(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteprefixSearchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteprefixSearch>>>
    export type DeleteprefixSearchMutationBody = PrefixSearchSettings
    export type DeleteprefixSearchMutationError = ResponseError

    /**
 * @summary Reset prefixSearch
 */
export const useDeleteprefixSearch = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteprefixSearch>>, TError,{indexUid: string;data: PrefixSearchSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteprefixSearch>>,
        TError,
        {indexUid: string;data: PrefixSearchSettings},
        TContext
      > => {

      const mutationOptions = getDeleteprefixSearchMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined proximityPrecision
 * @summary Get proximityPrecision
 */
export const getproximityPrecision = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProximityPrecisionView>(
      {url: `/indexes/${indexUid}/settings/proximity-precision`, method: 'GET', signal
    },
      options);
    }
  

export const getGetproximityPrecisionQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/proximity-precision`] as const;
    }

    
export const useGetproximityPrecisionInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getproximityPrecision>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getproximityPrecision>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetproximityPrecisionQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getproximityPrecision>>> = ({ signal }) => getproximityPrecision(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getproximityPrecision>>, TError, TData> & { queryKey: QueryKey }
}

export type GetproximityPrecisionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getproximityPrecision>>>
export type GetproximityPrecisionInfiniteQueryError = ResponseError


/**
 * @summary Get proximityPrecision
 */

export function useGetproximityPrecisionInfinite<TData = Awaited<ReturnType<typeof getproximityPrecision>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getproximityPrecision>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetproximityPrecisionInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetproximityPrecisionQueryOptions = <TData = Awaited<ReturnType<typeof getproximityPrecision>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getproximityPrecision>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetproximityPrecisionQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getproximityPrecision>>> = ({ signal }) => getproximityPrecision(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getproximityPrecision>>, TError, TData> & { queryKey: QueryKey }
}

export type GetproximityPrecisionQueryResult = NonNullable<Awaited<ReturnType<typeof getproximityPrecision>>>
export type GetproximityPrecisionQueryError = ResponseError


/**
 * @summary Get proximityPrecision
 */

export function useGetproximityPrecision<TData = Awaited<ReturnType<typeof getproximityPrecision>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getproximityPrecision>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetproximityPrecisionQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined proximityPrecision
 * @summary Update proximityPrecision
 */
export const putproximityPrecision = (
    indexUid: string,
    proximityPrecisionView: ProximityPrecisionView,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/proximity-precision`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: proximityPrecisionView
    },
      options);
    }
  


export const getPutproximityPrecisionMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putproximityPrecision>>, TError,{indexUid: string;data: ProximityPrecisionView}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putproximityPrecision>>, TError,{indexUid: string;data: ProximityPrecisionView}, TContext> => {

const mutationKey = ['putproximityPrecision'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putproximityPrecision>>, {indexUid: string;data: ProximityPrecisionView}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putproximityPrecision(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutproximityPrecisionMutationResult = NonNullable<Awaited<ReturnType<typeof putproximityPrecision>>>
    export type PutproximityPrecisionMutationBody = ProximityPrecisionView
    export type PutproximityPrecisionMutationError = ResponseError

    /**
 * @summary Update proximityPrecision
 */
export const usePutproximityPrecision = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putproximityPrecision>>, TError,{indexUid: string;data: ProximityPrecisionView}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putproximityPrecision>>,
        TError,
        {indexUid: string;data: ProximityPrecisionView},
        TContext
      > => {

      const mutationOptions = getPutproximityPrecisionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's proximityPrecision to its default value
 * @summary Reset proximityPrecision
 */
export const deleteproximityPrecision = (
    indexUid: string,
    proximityPrecisionView: ProximityPrecisionView,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/proximity-precision`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: proximityPrecisionView
    },
      options);
    }
  


export const getDeleteproximityPrecisionMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteproximityPrecision>>, TError,{indexUid: string;data: ProximityPrecisionView}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteproximityPrecision>>, TError,{indexUid: string;data: ProximityPrecisionView}, TContext> => {

const mutationKey = ['deleteproximityPrecision'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteproximityPrecision>>, {indexUid: string;data: ProximityPrecisionView}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleteproximityPrecision(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteproximityPrecisionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteproximityPrecision>>>
    export type DeleteproximityPrecisionMutationBody = ProximityPrecisionView
    export type DeleteproximityPrecisionMutationError = ResponseError

    /**
 * @summary Reset proximityPrecision
 */
export const useDeleteproximityPrecision = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteproximityPrecision>>, TError,{indexUid: string;data: ProximityPrecisionView}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteproximityPrecision>>,
        TError,
        {indexUid: string;data: ProximityPrecisionView},
        TContext
      > => {

      const mutationOptions = getDeleteproximityPrecisionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined rankingRules
 * @summary Get rankingRules
 */
export const getrankingRules = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RankingRuleView[]>(
      {url: `/indexes/${indexUid}/settings/ranking-rules`, method: 'GET', signal
    },
      options);
    }
  

export const getGetrankingRulesQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/ranking-rules`] as const;
    }

    
export const useGetrankingRulesInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getrankingRules>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getrankingRules>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetrankingRulesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getrankingRules>>> = ({ signal }) => getrankingRules(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getrankingRules>>, TError, TData> & { queryKey: QueryKey }
}

export type GetrankingRulesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getrankingRules>>>
export type GetrankingRulesInfiniteQueryError = ResponseError


/**
 * @summary Get rankingRules
 */

export function useGetrankingRulesInfinite<TData = Awaited<ReturnType<typeof getrankingRules>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getrankingRules>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetrankingRulesInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetrankingRulesQueryOptions = <TData = Awaited<ReturnType<typeof getrankingRules>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getrankingRules>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetrankingRulesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getrankingRules>>> = ({ signal }) => getrankingRules(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getrankingRules>>, TError, TData> & { queryKey: QueryKey }
}

export type GetrankingRulesQueryResult = NonNullable<Awaited<ReturnType<typeof getrankingRules>>>
export type GetrankingRulesQueryError = ResponseError


/**
 * @summary Get rankingRules
 */

export function useGetrankingRules<TData = Awaited<ReturnType<typeof getrankingRules>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getrankingRules>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetrankingRulesQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined rankingRules
 * @summary Update rankingRules
 */
export const putrankingRules = (
    indexUid: string,
    rankingRuleView: RankingRuleView[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/ranking-rules`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: rankingRuleView
    },
      options);
    }
  


export const getPutrankingRulesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putrankingRules>>, TError,{indexUid: string;data: RankingRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putrankingRules>>, TError,{indexUid: string;data: RankingRuleView[]}, TContext> => {

const mutationKey = ['putrankingRules'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putrankingRules>>, {indexUid: string;data: RankingRuleView[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putrankingRules(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutrankingRulesMutationResult = NonNullable<Awaited<ReturnType<typeof putrankingRules>>>
    export type PutrankingRulesMutationBody = RankingRuleView[]
    export type PutrankingRulesMutationError = ResponseError

    /**
 * @summary Update rankingRules
 */
export const usePutrankingRules = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putrankingRules>>, TError,{indexUid: string;data: RankingRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putrankingRules>>,
        TError,
        {indexUid: string;data: RankingRuleView[]},
        TContext
      > => {

      const mutationOptions = getPutrankingRulesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's rankingRules to its default value
 * @summary Reset rankingRules
 */
export const deleterankingRules = (
    indexUid: string,
    rankingRuleView: RankingRuleView[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/ranking-rules`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: rankingRuleView
    },
      options);
    }
  


export const getDeleterankingRulesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleterankingRules>>, TError,{indexUid: string;data: RankingRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleterankingRules>>, TError,{indexUid: string;data: RankingRuleView[]}, TContext> => {

const mutationKey = ['deleterankingRules'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleterankingRules>>, {indexUid: string;data: RankingRuleView[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleterankingRules(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleterankingRulesMutationResult = NonNullable<Awaited<ReturnType<typeof deleterankingRules>>>
    export type DeleterankingRulesMutationBody = RankingRuleView[]
    export type DeleterankingRulesMutationError = ResponseError

    /**
 * @summary Reset rankingRules
 */
export const useDeleterankingRules = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleterankingRules>>, TError,{indexUid: string;data: RankingRuleView[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleterankingRules>>,
        TError,
        {indexUid: string;data: RankingRuleView[]},
        TContext
      > => {

      const mutationOptions = getDeleterankingRulesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined searchCutoffMs
 * @summary Get searchCutoffMs
 */
export const getsearchCutoffMs = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<number>(
      {url: `/indexes/${indexUid}/settings/search-cutoff-ms`, method: 'GET', signal
    },
      options);
    }
  

export const getGetsearchCutoffMsQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/search-cutoff-ms`] as const;
    }

    
export const useGetsearchCutoffMsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getsearchCutoffMs>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsearchCutoffMs>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsearchCutoffMsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsearchCutoffMs>>> = ({ signal }) => getsearchCutoffMs(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsearchCutoffMs>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsearchCutoffMsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getsearchCutoffMs>>>
export type GetsearchCutoffMsInfiniteQueryError = ResponseError


/**
 * @summary Get searchCutoffMs
 */

export function useGetsearchCutoffMsInfinite<TData = Awaited<ReturnType<typeof getsearchCutoffMs>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsearchCutoffMs>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsearchCutoffMsInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetsearchCutoffMsQueryOptions = <TData = Awaited<ReturnType<typeof getsearchCutoffMs>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsearchCutoffMs>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsearchCutoffMsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsearchCutoffMs>>> = ({ signal }) => getsearchCutoffMs(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getsearchCutoffMs>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsearchCutoffMsQueryResult = NonNullable<Awaited<ReturnType<typeof getsearchCutoffMs>>>
export type GetsearchCutoffMsQueryError = ResponseError


/**
 * @summary Get searchCutoffMs
 */

export function useGetsearchCutoffMs<TData = Awaited<ReturnType<typeof getsearchCutoffMs>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsearchCutoffMs>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsearchCutoffMsQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined searchCutoffMs
 * @summary Update searchCutoffMs
 */
export const putsearchCutoffMs = (
    indexUid: string,
    putsearchCutoffMsBody: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/search-cutoff-ms`, method: 'PUT',
      headers: {'Content-Type': 'text/plain', },
      data: putsearchCutoffMsBody
    },
      options);
    }
  


export const getPutsearchCutoffMsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsearchCutoffMs>>, TError,{indexUid: string;data: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putsearchCutoffMs>>, TError,{indexUid: string;data: number}, TContext> => {

const mutationKey = ['putsearchCutoffMs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putsearchCutoffMs>>, {indexUid: string;data: number}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putsearchCutoffMs(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutsearchCutoffMsMutationResult = NonNullable<Awaited<ReturnType<typeof putsearchCutoffMs>>>
    export type PutsearchCutoffMsMutationBody = number
    export type PutsearchCutoffMsMutationError = ResponseError

    /**
 * @summary Update searchCutoffMs
 */
export const usePutsearchCutoffMs = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsearchCutoffMs>>, TError,{indexUid: string;data: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putsearchCutoffMs>>,
        TError,
        {indexUid: string;data: number},
        TContext
      > => {

      const mutationOptions = getPutsearchCutoffMsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's searchCutoffMs to its default value
 * @summary Reset searchCutoffMs
 */
export const deletesearchCutoffMs = (
    indexUid: string,
    deletesearchCutoffMsBody: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/search-cutoff-ms`, method: 'DELETE',
      headers: {'Content-Type': 'text/plain', },
      data: deletesearchCutoffMsBody
    },
      options);
    }
  


export const getDeletesearchCutoffMsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesearchCutoffMs>>, TError,{indexUid: string;data: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletesearchCutoffMs>>, TError,{indexUid: string;data: number}, TContext> => {

const mutationKey = ['deletesearchCutoffMs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletesearchCutoffMs>>, {indexUid: string;data: number}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletesearchCutoffMs(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletesearchCutoffMsMutationResult = NonNullable<Awaited<ReturnType<typeof deletesearchCutoffMs>>>
    export type DeletesearchCutoffMsMutationBody = number
    export type DeletesearchCutoffMsMutationError = ResponseError

    /**
 * @summary Reset searchCutoffMs
 */
export const useDeletesearchCutoffMs = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesearchCutoffMs>>, TError,{indexUid: string;data: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletesearchCutoffMs>>,
        TError,
        {indexUid: string;data: number},
        TContext
      > => {

      const mutationOptions = getDeletesearchCutoffMsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined searchableAttributes
 * @summary Get searchableAttributes
 */
export const getsearchableAttributes = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/searchable-attributes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetsearchableAttributesQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/searchable-attributes`] as const;
    }

    
export const useGetsearchableAttributesInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getsearchableAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsearchableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsearchableAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsearchableAttributes>>> = ({ signal }) => getsearchableAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsearchableAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsearchableAttributesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getsearchableAttributes>>>
export type GetsearchableAttributesInfiniteQueryError = ResponseError


/**
 * @summary Get searchableAttributes
 */

export function useGetsearchableAttributesInfinite<TData = Awaited<ReturnType<typeof getsearchableAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsearchableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsearchableAttributesInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetsearchableAttributesQueryOptions = <TData = Awaited<ReturnType<typeof getsearchableAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsearchableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsearchableAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsearchableAttributes>>> = ({ signal }) => getsearchableAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getsearchableAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsearchableAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof getsearchableAttributes>>>
export type GetsearchableAttributesQueryError = ResponseError


/**
 * @summary Get searchableAttributes
 */

export function useGetsearchableAttributes<TData = Awaited<ReturnType<typeof getsearchableAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsearchableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsearchableAttributesQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined searchableAttributes
 * @summary Update searchableAttributes
 */
export const putsearchableAttributes = (
    indexUid: string,
    putsearchableAttributesBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/searchable-attributes`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putsearchableAttributesBody
    },
      options);
    }
  


export const getPutsearchableAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsearchableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putsearchableAttributes>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putsearchableAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putsearchableAttributes>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putsearchableAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutsearchableAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof putsearchableAttributes>>>
    export type PutsearchableAttributesMutationBody = string[]
    export type PutsearchableAttributesMutationError = ResponseError

    /**
 * @summary Update searchableAttributes
 */
export const usePutsearchableAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsearchableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putsearchableAttributes>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutsearchableAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's searchableAttributes to its default value
 * @summary Reset searchableAttributes
 */
export const deletesearchableAttributes = (
    indexUid: string,
    deletesearchableAttributesBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/searchable-attributes`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletesearchableAttributesBody
    },
      options);
    }
  


export const getDeletesearchableAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesearchableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletesearchableAttributes>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deletesearchableAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletesearchableAttributes>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletesearchableAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletesearchableAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof deletesearchableAttributes>>>
    export type DeletesearchableAttributesMutationBody = string[]
    export type DeletesearchableAttributesMutationError = ResponseError

    /**
 * @summary Reset searchableAttributes
 */
export const useDeletesearchableAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesearchableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletesearchableAttributes>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeletesearchableAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined separatorTokens
 * @summary Get separatorTokens
 */
export const getseparatorTokens = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/separator-tokens`, method: 'GET', signal
    },
      options);
    }
  

export const getGetseparatorTokensQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/separator-tokens`] as const;
    }

    
export const useGetseparatorTokensInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getseparatorTokens>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getseparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetseparatorTokensQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getseparatorTokens>>> = ({ signal }) => getseparatorTokens(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getseparatorTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type GetseparatorTokensInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getseparatorTokens>>>
export type GetseparatorTokensInfiniteQueryError = ResponseError


/**
 * @summary Get separatorTokens
 */

export function useGetseparatorTokensInfinite<TData = Awaited<ReturnType<typeof getseparatorTokens>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getseparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetseparatorTokensInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetseparatorTokensQueryOptions = <TData = Awaited<ReturnType<typeof getseparatorTokens>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getseparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetseparatorTokensQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getseparatorTokens>>> = ({ signal }) => getseparatorTokens(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getseparatorTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type GetseparatorTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getseparatorTokens>>>
export type GetseparatorTokensQueryError = ResponseError


/**
 * @summary Get separatorTokens
 */

export function useGetseparatorTokens<TData = Awaited<ReturnType<typeof getseparatorTokens>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getseparatorTokens>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetseparatorTokensQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined separatorTokens
 * @summary Update separatorTokens
 */
export const putseparatorTokens = (
    indexUid: string,
    putseparatorTokensBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/separator-tokens`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putseparatorTokensBody
    },
      options);
    }
  


export const getPutseparatorTokensMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putseparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putseparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putseparatorTokens'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putseparatorTokens>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putseparatorTokens(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutseparatorTokensMutationResult = NonNullable<Awaited<ReturnType<typeof putseparatorTokens>>>
    export type PutseparatorTokensMutationBody = string[]
    export type PutseparatorTokensMutationError = ResponseError

    /**
 * @summary Update separatorTokens
 */
export const usePutseparatorTokens = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putseparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putseparatorTokens>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutseparatorTokensMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's separatorTokens to its default value
 * @summary Reset separatorTokens
 */
export const deleteseparatorTokens = (
    indexUid: string,
    deleteseparatorTokensBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/separator-tokens`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteseparatorTokensBody
    },
      options);
    }
  


export const getDeleteseparatorTokensMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteseparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteseparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deleteseparatorTokens'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteseparatorTokens>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleteseparatorTokens(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteseparatorTokensMutationResult = NonNullable<Awaited<ReturnType<typeof deleteseparatorTokens>>>
    export type DeleteseparatorTokensMutationBody = string[]
    export type DeleteseparatorTokensMutationError = ResponseError

    /**
 * @summary Reset separatorTokens
 */
export const useDeleteseparatorTokens = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteseparatorTokens>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteseparatorTokens>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeleteseparatorTokensMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined sortableAttributes
 * @summary Get sortableAttributes
 */
export const getsortableAttributes = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/sortable-attributes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetsortableAttributesQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/sortable-attributes`] as const;
    }

    
export const useGetsortableAttributesInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getsortableAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsortableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsortableAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsortableAttributes>>> = ({ signal }) => getsortableAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsortableAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsortableAttributesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getsortableAttributes>>>
export type GetsortableAttributesInfiniteQueryError = ResponseError


/**
 * @summary Get sortableAttributes
 */

export function useGetsortableAttributesInfinite<TData = Awaited<ReturnType<typeof getsortableAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsortableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsortableAttributesInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetsortableAttributesQueryOptions = <TData = Awaited<ReturnType<typeof getsortableAttributes>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsortableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsortableAttributesQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsortableAttributes>>> = ({ signal }) => getsortableAttributes(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getsortableAttributes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsortableAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof getsortableAttributes>>>
export type GetsortableAttributesQueryError = ResponseError


/**
 * @summary Get sortableAttributes
 */

export function useGetsortableAttributes<TData = Awaited<ReturnType<typeof getsortableAttributes>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsortableAttributes>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsortableAttributesQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined sortableAttributes
 * @summary Update sortableAttributes
 */
export const putsortableAttributes = (
    indexUid: string,
    putsortableAttributesBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/sortable-attributes`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putsortableAttributesBody
    },
      options);
    }
  


export const getPutsortableAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsortableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putsortableAttributes>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putsortableAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putsortableAttributes>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putsortableAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutsortableAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof putsortableAttributes>>>
    export type PutsortableAttributesMutationBody = string[]
    export type PutsortableAttributesMutationError = ResponseError

    /**
 * @summary Update sortableAttributes
 */
export const usePutsortableAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsortableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putsortableAttributes>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutsortableAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's sortableAttributes to its default value
 * @summary Reset sortableAttributes
 */
export const deletesortableAttributes = (
    indexUid: string,
    deletesortableAttributesBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/sortable-attributes`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletesortableAttributesBody
    },
      options);
    }
  


export const getDeletesortableAttributesMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesortableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletesortableAttributes>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deletesortableAttributes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletesortableAttributes>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletesortableAttributes(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletesortableAttributesMutationResult = NonNullable<Awaited<ReturnType<typeof deletesortableAttributes>>>
    export type DeletesortableAttributesMutationBody = string[]
    export type DeletesortableAttributesMutationError = ResponseError

    /**
 * @summary Reset sortableAttributes
 */
export const useDeletesortableAttributes = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesortableAttributes>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletesortableAttributes>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeletesortableAttributesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined stopWords
 * @summary Get stopWords
 */
export const getstopWords = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/indexes/${indexUid}/settings/stop-words`, method: 'GET', signal
    },
      options);
    }
  

export const getGetstopWordsQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/stop-words`] as const;
    }

    
export const useGetstopWordsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getstopWords>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getstopWords>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetstopWordsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getstopWords>>> = ({ signal }) => getstopWords(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getstopWords>>, TError, TData> & { queryKey: QueryKey }
}

export type GetstopWordsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getstopWords>>>
export type GetstopWordsInfiniteQueryError = ResponseError


/**
 * @summary Get stopWords
 */

export function useGetstopWordsInfinite<TData = Awaited<ReturnType<typeof getstopWords>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getstopWords>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetstopWordsInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetstopWordsQueryOptions = <TData = Awaited<ReturnType<typeof getstopWords>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getstopWords>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetstopWordsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getstopWords>>> = ({ signal }) => getstopWords(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getstopWords>>, TError, TData> & { queryKey: QueryKey }
}

export type GetstopWordsQueryResult = NonNullable<Awaited<ReturnType<typeof getstopWords>>>
export type GetstopWordsQueryError = ResponseError


/**
 * @summary Get stopWords
 */

export function useGetstopWords<TData = Awaited<ReturnType<typeof getstopWords>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getstopWords>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetstopWordsQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined stopWords
 * @summary Update stopWords
 */
export const putstopWords = (
    indexUid: string,
    putstopWordsBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/stop-words`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putstopWordsBody
    },
      options);
    }
  


export const getPutstopWordsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putstopWords>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putstopWords>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['putstopWords'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putstopWords>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putstopWords(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutstopWordsMutationResult = NonNullable<Awaited<ReturnType<typeof putstopWords>>>
    export type PutstopWordsMutationBody = string[]
    export type PutstopWordsMutationError = ResponseError

    /**
 * @summary Update stopWords
 */
export const usePutstopWords = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putstopWords>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putstopWords>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getPutstopWordsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's stopWords to its default value
 * @summary Reset stopWords
 */
export const deletestopWords = (
    indexUid: string,
    deletestopWordsBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/stop-words`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletestopWordsBody
    },
      options);
    }
  


export const getDeletestopWordsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletestopWords>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletestopWords>>, TError,{indexUid: string;data: string[]}, TContext> => {

const mutationKey = ['deletestopWords'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletestopWords>>, {indexUid: string;data: string[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletestopWords(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletestopWordsMutationResult = NonNullable<Awaited<ReturnType<typeof deletestopWords>>>
    export type DeletestopWordsMutationBody = string[]
    export type DeletestopWordsMutationError = ResponseError

    /**
 * @summary Reset stopWords
 */
export const useDeletestopWords = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletestopWords>>, TError,{indexUid: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletestopWords>>,
        TError,
        {indexUid: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeletestopWordsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined synonyms
 * @summary Get synonyms
 */
export const getsynonyms = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Getsynonyms200>(
      {url: `/indexes/${indexUid}/settings/synonyms`, method: 'GET', signal
    },
      options);
    }
  

export const getGetsynonymsQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/synonyms`] as const;
    }

    
export const useGetsynonymsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getsynonyms>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsynonyms>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsynonymsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsynonyms>>> = ({ signal }) => getsynonyms(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsynonyms>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsynonymsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getsynonyms>>>
export type GetsynonymsInfiniteQueryError = ResponseError


/**
 * @summary Get synonyms
 */

export function useGetsynonymsInfinite<TData = Awaited<ReturnType<typeof getsynonyms>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getsynonyms>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsynonymsInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetsynonymsQueryOptions = <TData = Awaited<ReturnType<typeof getsynonyms>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsynonyms>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetsynonymsQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getsynonyms>>> = ({ signal }) => getsynonyms(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getsynonyms>>, TError, TData> & { queryKey: QueryKey }
}

export type GetsynonymsQueryResult = NonNullable<Awaited<ReturnType<typeof getsynonyms>>>
export type GetsynonymsQueryError = ResponseError


/**
 * @summary Get synonyms
 */

export function useGetsynonyms<TData = Awaited<ReturnType<typeof getsynonyms>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getsynonyms>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetsynonymsQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an index's user defined synonyms
 * @summary Update synonyms
 */
export const putsynonyms = (
    indexUid: string,
    putsynonymsBody: PutsynonymsBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/synonyms`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putsynonymsBody
    },
      options);
    }
  


export const getPutsynonymsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsynonyms>>, TError,{indexUid: string;data: PutsynonymsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putsynonyms>>, TError,{indexUid: string;data: PutsynonymsBody}, TContext> => {

const mutationKey = ['putsynonyms'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putsynonyms>>, {indexUid: string;data: PutsynonymsBody}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  putsynonyms(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutsynonymsMutationResult = NonNullable<Awaited<ReturnType<typeof putsynonyms>>>
    export type PutsynonymsMutationBody = PutsynonymsBody
    export type PutsynonymsMutationError = ResponseError

    /**
 * @summary Update synonyms
 */
export const usePutsynonyms = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putsynonyms>>, TError,{indexUid: string;data: PutsynonymsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putsynonyms>>,
        TError,
        {indexUid: string;data: PutsynonymsBody},
        TContext
      > => {

      const mutationOptions = getPutsynonymsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset an index's synonyms to its default value
 * @summary Reset synonyms
 */
export const deletesynonyms = (
    indexUid: string,
    deletesynonymsBody: DeletesynonymsBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/synonyms`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletesynonymsBody
    },
      options);
    }
  


export const getDeletesynonymsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesynonyms>>, TError,{indexUid: string;data: DeletesynonymsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletesynonyms>>, TError,{indexUid: string;data: DeletesynonymsBody}, TContext> => {

const mutationKey = ['deletesynonyms'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletesynonyms>>, {indexUid: string;data: DeletesynonymsBody}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletesynonyms(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletesynonymsMutationResult = NonNullable<Awaited<ReturnType<typeof deletesynonyms>>>
    export type DeletesynonymsMutationBody = DeletesynonymsBody
    export type DeletesynonymsMutationError = ResponseError

    /**
 * @summary Reset synonyms
 */
export const useDeletesynonyms = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletesynonyms>>, TError,{indexUid: string;data: DeletesynonymsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletesynonyms>>,
        TError,
        {indexUid: string;data: DeletesynonymsBody},
        TContext
      > => {

      const mutationOptions = getDeletesynonymsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an user defined typoTolerance
 * @summary Get typoTolerance
 */
export const gettypoTolerance = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TypoSettings>(
      {url: `/indexes/${indexUid}/settings/typo-tolerance`, method: 'GET', signal
    },
      options);
    }
  

export const getGettypoToleranceQueryKey = (indexUid: string,) => {
    return [`/indexes/${indexUid}/settings/typo-tolerance`] as const;
    }

    
export const useGettypoToleranceInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof gettypoTolerance>>, TError = ResponseError>(indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof gettypoTolerance>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGettypoToleranceQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gettypoTolerance>>> = ({ signal }) => gettypoTolerance(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof gettypoTolerance>>, TError, TData> & { queryKey: QueryKey }
}

export type GettypoToleranceInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof gettypoTolerance>>>
export type GettypoToleranceInfiniteQueryError = ResponseError


/**
 * @summary Get typoTolerance
 */

export function useGettypoToleranceInfinite<TData = Awaited<ReturnType<typeof gettypoTolerance>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof gettypoTolerance>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGettypoToleranceInfiniteQueryOptions(indexUid,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGettypoToleranceQueryOptions = <TData = Awaited<ReturnType<typeof gettypoTolerance>>, TError = ResponseError>(indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gettypoTolerance>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGettypoToleranceQueryKey(indexUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gettypoTolerance>>> = ({ signal }) => gettypoTolerance(indexUid, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof gettypoTolerance>>, TError, TData> & { queryKey: QueryKey }
}

export type GettypoToleranceQueryResult = NonNullable<Awaited<ReturnType<typeof gettypoTolerance>>>
export type GettypoToleranceQueryError = ResponseError


/**
 * @summary Get typoTolerance
 */

export function useGettypoTolerance<TData = Awaited<ReturnType<typeof gettypoTolerance>>, TError = ResponseError>(
 indexUid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gettypoTolerance>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGettypoToleranceQueryOptions(indexUid,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Reset an index's typoTolerance to its default value
 * @summary Reset typoTolerance
 */
export const deletetypoTolerance = (
    indexUid: string,
    typoSettings: TypoSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/typo-tolerance`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: typoSettings
    },
      options);
    }
  


export const getDeletetypoToleranceMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletetypoTolerance>>, TError,{indexUid: string;data: TypoSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletetypoTolerance>>, TError,{indexUid: string;data: TypoSettings}, TContext> => {

const mutationKey = ['deletetypoTolerance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletetypoTolerance>>, {indexUid: string;data: TypoSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deletetypoTolerance(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletetypoToleranceMutationResult = NonNullable<Awaited<ReturnType<typeof deletetypoTolerance>>>
    export type DeletetypoToleranceMutationBody = TypoSettings
    export type DeletetypoToleranceMutationError = ResponseError

    /**
 * @summary Reset typoTolerance
 */
export const useDeletetypoTolerance = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletetypoTolerance>>, TError,{indexUid: string;data: TypoSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deletetypoTolerance>>,
        TError,
        {indexUid: string;data: TypoSettings},
        TContext
      > => {

      const mutationOptions = getDeletetypoToleranceMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update an index's user defined typoTolerance
 * @summary Update typoTolerance
 */
export const patchtypoTolerance = (
    indexUid: string,
    typoSettings: TypoSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/settings/typo-tolerance`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: typoSettings
    },
      options);
    }
  


export const getPatchtypoToleranceMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchtypoTolerance>>, TError,{indexUid: string;data: TypoSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchtypoTolerance>>, TError,{indexUid: string;data: TypoSettings}, TContext> => {

const mutationKey = ['patchtypoTolerance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchtypoTolerance>>, {indexUid: string;data: TypoSettings}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  patchtypoTolerance(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchtypoToleranceMutationResult = NonNullable<Awaited<ReturnType<typeof patchtypoTolerance>>>
    export type PatchtypoToleranceMutationBody = TypoSettings
    export type PatchtypoToleranceMutationError = ResponseError

    /**
 * @summary Update typoTolerance
 */
export const usePatchtypoTolerance = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchtypoTolerance>>, TError,{indexUid: string;data: TypoSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchtypoTolerance>>,
        TError,
        {indexUid: string;data: TypoSettings},
        TContext
      > => {

      const mutationOptions = getPatchtypoToleranceMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
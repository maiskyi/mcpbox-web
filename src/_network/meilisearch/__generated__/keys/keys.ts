/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * meilisearch
 * Meilisearch HTTP server
 * OpenAPI spec version: 1.15.2
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateApiKey,
  KeyView,
  ListApiKeysParams,
  PaginationViewKeyView,
  PatchApiKey,
  ResponseError
} from '../api.schemas';

import { customInstance } from '../../utils/orval/orval.utils';
import { customQueryOptions } from '../../utils/orval/orval.utils';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List all API Keys
 * @summary Get API Keys
 */
export const listApiKeys = (
    params: ListApiKeysParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginationViewKeyView>(
      {url: `/keys`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListApiKeysQueryKey = (params: ListApiKeysParams,) => {
    return [`/keys`, ...(params ? [params]: [])] as const;
    }

    
export const useListApiKeysInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof listApiKeys>>, TError = ResponseError>(params: ListApiKeysParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof listApiKeys>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListApiKeysQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listApiKeys>>> = ({ signal, pageParam }) => listApiKeys({...params, 'skip': pageParam || params?.['skip']}, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listApiKeys>>, TError, TData> & { queryKey: QueryKey }
}

export type ListApiKeysInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listApiKeys>>>
export type ListApiKeysInfiniteQueryError = ResponseError


/**
 * @summary Get API Keys
 */

export function useListApiKeysInfinite<TData = Awaited<ReturnType<typeof listApiKeys>>, TError = ResponseError>(
 params: ListApiKeysParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof listApiKeys>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useListApiKeysInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useListApiKeysQueryOptions = <TData = Awaited<ReturnType<typeof listApiKeys>>, TError = ResponseError>(params: ListApiKeysParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listApiKeys>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListApiKeysQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listApiKeys>>> = ({ signal }) => listApiKeys(params, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof listApiKeys>>, TError, TData> & { queryKey: QueryKey }
}

export type ListApiKeysQueryResult = NonNullable<Awaited<ReturnType<typeof listApiKeys>>>
export type ListApiKeysQueryError = ResponseError


/**
 * @summary Get API Keys
 */

export function useListApiKeys<TData = Awaited<ReturnType<typeof listApiKeys>>, TError = ResponseError>(
 params: ListApiKeysParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listApiKeys>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useListApiKeysQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create an API Key.
 * @summary Create an API Key
 */
export const createApiKey = (
    createApiKey: CreateApiKey,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<KeyView>(
      {url: `/keys`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createApiKey, signal
    },
      options);
    }
  


export const getCreateApiKeyMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createApiKey>>, TError,{data: CreateApiKey}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createApiKey>>, TError,{data: CreateApiKey}, TContext> => {

const mutationKey = ['createApiKey'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createApiKey>>, {data: CreateApiKey}> = (props) => {
          const {data} = props ?? {};

          return  createApiKey(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateApiKeyMutationResult = NonNullable<Awaited<ReturnType<typeof createApiKey>>>
    export type CreateApiKeyMutationBody = CreateApiKey
    export type CreateApiKeyMutationError = ResponseError

    /**
 * @summary Create an API Key
 */
export const useCreateApiKey = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createApiKey>>, TError,{data: CreateApiKey}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createApiKey>>,
        TError,
        {data: CreateApiKey},
        TContext
      > => {

      const mutationOptions = getCreateApiKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get an API key from its `uid` or its `key` field.
 * @summary Get an API Key
 */
export const getApiKey = (
    uidOrKey: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<KeyView>(
      {url: `/keys/${uidOrKey}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetApiKeyQueryKey = (uidOrKey: string,) => {
    return [`/keys/${uidOrKey}`] as const;
    }

    
export const useGetApiKeyInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getApiKey>>, TError = ResponseError>(uidOrKey: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiKey>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKeyQueryKey(uidOrKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKey>>> = ({ signal }) => getApiKey(uidOrKey, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiKey>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiKeyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKey>>>
export type GetApiKeyInfiniteQueryError = ResponseError


/**
 * @summary Get an API Key
 */

export function useGetApiKeyInfinite<TData = Awaited<ReturnType<typeof getApiKey>>, TError = ResponseError>(
 uidOrKey: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiKey>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetApiKeyInfiniteQueryOptions(uidOrKey,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetApiKeyQueryOptions = <TData = Awaited<ReturnType<typeof getApiKey>>, TError = ResponseError>(uidOrKey: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiKey>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKeyQueryKey(uidOrKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKey>>> = ({ signal }) => getApiKey(uidOrKey, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getApiKey>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKey>>>
export type GetApiKeyQueryError = ResponseError


/**
 * @summary Get an API Key
 */

export function useGetApiKey<TData = Awaited<ReturnType<typeof getApiKey>>, TError = ResponseError>(
 uidOrKey: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiKey>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetApiKeyQueryOptions(uidOrKey,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Delete the specified API key.
 * @summary Delete a key
 */
export const deleteApiKey = (
    uidOrKey: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/keys/${uidOrKey}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteApiKeyMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiKey>>, TError,{uidOrKey: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiKey>>, TError,{uidOrKey: string}, TContext> => {

const mutationKey = ['deleteApiKey'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiKey>>, {uidOrKey: string}> = (props) => {
          const {uidOrKey} = props ?? {};

          return  deleteApiKey(uidOrKey,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiKeyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiKey>>>
    
    export type DeleteApiKeyMutationError = ResponseError

    /**
 * @summary Delete a key
 */
export const useDeleteApiKey = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiKey>>, TError,{uidOrKey: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiKey>>,
        TError,
        {uidOrKey: string},
        TContext
      > => {

      const mutationOptions = getDeleteApiKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Update the name and description of an API key.
Updates to keys are partial. This means you should provide only the fields you intend to update, as any fields not present in the payload will remain unchanged.
 * @summary Update a Key
 */
export const patchApiKey = (
    uidOrKey: string,
    patchApiKey: PatchApiKey,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<KeyView>(
      {url: `/keys/${uidOrKey}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchApiKey
    },
      options);
    }
  


export const getPatchApiKeyMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiKey>>, TError,{uidOrKey: string;data: PatchApiKey}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiKey>>, TError,{uidOrKey: string;data: PatchApiKey}, TContext> => {

const mutationKey = ['patchApiKey'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiKey>>, {uidOrKey: string;data: PatchApiKey}> = (props) => {
          const {uidOrKey,data} = props ?? {};

          return  patchApiKey(uidOrKey,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiKeyMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiKey>>>
    export type PatchApiKeyMutationBody = PatchApiKey
    export type PatchApiKeyMutationError = ResponseError

    /**
 * @summary Update a Key
 */
export const usePatchApiKey = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiKey>>, TError,{uidOrKey: string;data: PatchApiKey}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchApiKey>>,
        TError,
        {uidOrKey: string;data: PatchApiKey},
        TContext
      > => {

      const mutationOptions = getPatchApiKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
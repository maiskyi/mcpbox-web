/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * meilisearch
 * Meilisearch HTTP server
 * OpenAPI spec version: 1.15.2
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BrowseQuery,
  DocumentDeletionByFilter,
  DocumentEditionByFunction,
  GetDocumentParams,
  GetDocumentsParams,
  PaginationViewValue,
  ReplaceDocumentsParams,
  ResponseError,
  SummarizedTaskView,
  UpdateDocumentsParams
} from '../api.schemas';

import { customInstance } from '../../utils/orval/orval.utils';
import { customQueryOptions } from '../../utils/orval/orval.utils';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Delete a set of documents based on an array of document ids.
 * @summary Delete documents by batch
 */
export const deleteDocumentsBatch = (
    indexUid: string,
    deleteDocumentsBatchBody: unknown[],
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/delete-batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: deleteDocumentsBatchBody, signal
    },
      options);
    }
  


export const getDeleteDocumentsBatchMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentsBatch>>, TError,{indexUid: string;data: unknown[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentsBatch>>, TError,{indexUid: string;data: unknown[]}, TContext> => {

const mutationKey = ['deleteDocumentsBatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocumentsBatch>>, {indexUid: string;data: unknown[]}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleteDocumentsBatch(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentsBatchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocumentsBatch>>>
    export type DeleteDocumentsBatchMutationBody = unknown[]
    export type DeleteDocumentsBatchMutationError = ResponseError

    /**
 * @summary Delete documents by batch
 */
export const useDeleteDocumentsBatch = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentsBatch>>, TError,{indexUid: string;data: unknown[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocumentsBatch>>,
        TError,
        {indexUid: string;data: unknown[]},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentsBatchMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get documents by batches.
 * @summary Get documents
 */
export const getDocuments = (
    indexUid: string,
    params?: GetDocumentsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginationViewValue>(
      {url: `/indexes/${indexUid}/documents`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetDocumentsQueryKey = (indexUid: string,
    params?: GetDocumentsParams,) => {
    return [`/indexes/${indexUid}/documents`, ...(params ? [params]: [])] as const;
    }

    
export const useGetDocumentsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getDocuments>>, TError = ResponseError>(indexUid: string,
    params?: GetDocumentsParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentsQueryKey(indexUid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocuments>>> = ({ signal, pageParam }) => getDocuments(indexUid,{...params, 'skip': pageParam || params?.['skip']}, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDocumentsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDocuments>>>
export type GetDocumentsInfiniteQueryError = ResponseError


/**
 * @summary Get documents
 */

export function useGetDocumentsInfinite<TData = Awaited<ReturnType<typeof getDocuments>>, TError = ResponseError>(
 indexUid: string,
    params?: GetDocumentsParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetDocumentsInfiniteQueryOptions(indexUid,params,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof getDocuments>>, TError = ResponseError>(indexUid: string,
    params?: GetDocumentsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentsQueryKey(indexUid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocuments>>> = ({ signal }) => getDocuments(indexUid,params, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof getDocuments>>>
export type GetDocumentsQueryError = ResponseError


/**
 * @summary Get documents
 */

export function useGetDocuments<TData = Awaited<ReturnType<typeof getDocuments>>, TError = ResponseError>(
 indexUid: string,
    params?: GetDocumentsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetDocumentsQueryOptions(indexUid,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Add a list of documents or update them if they already exist.
If you send an already existing document (same id) the old document will be only partially updated according to the fields of the new document. Thus, any fields not present in the new document are kept and remained unchanged.
To completely overwrite a document, see Add or replace documents route.
> info
> If the provided index does not exist, it will be created.
> info
> Use the reserved `_geo` object to add geo coordinates to a document. `_geo` is an object made of `lat` and `lng` field.
>
> When the vectorStore feature is enabled you can use the reserved `_vectors` field in your documents.
> It can accept an array of floats, multiple arrays of floats in an outer array or an object.
> This object accepts keys corresponding to the different embedders defined your index settings.
 * @summary Add or update documents
 */
export const updateDocuments = (
    indexUid: string,
    updateDocumentsBody: unknown,
    params: UpdateDocumentsParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/documents`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateDocumentsBody,
        params
    },
      options);
    }
  


export const getUpdateDocumentsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocuments>>, TError,{indexUid: string;data: unknown;params: UpdateDocumentsParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDocuments>>, TError,{indexUid: string;data: unknown;params: UpdateDocumentsParams}, TContext> => {

const mutationKey = ['updateDocuments'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDocuments>>, {indexUid: string;data: unknown;params: UpdateDocumentsParams}> = (props) => {
          const {indexUid,data,params} = props ?? {};

          return  updateDocuments(indexUid,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDocumentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateDocuments>>>
    export type UpdateDocumentsMutationBody = unknown
    export type UpdateDocumentsMutationError = ResponseError

    /**
 * @summary Add or update documents
 */
export const useUpdateDocuments = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocuments>>, TError,{indexUid: string;data: unknown;params: UpdateDocumentsParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateDocuments>>,
        TError,
        {indexUid: string;data: unknown;params: UpdateDocumentsParams},
        TContext
      > => {

      const mutationOptions = getUpdateDocumentsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Add a list of documents or replace them if they already exist.

If you send an already existing document (same id) the whole existing document will be overwritten by the new document. Fields previously in the document not present in the new document are removed.

For a partial update of the document see Add or update documents route.
> info
> If the provided index does not exist, it will be created.
> info
> Use the reserved `_geo` object to add geo coordinates to a document. `_geo` is an object made of `lat` and `lng` field.
>
> When the vectorStore feature is enabled you can use the reserved `_vectors` field in your documents.
> It can accept an array of floats, multiple arrays of floats in an outer array or an object.
> This object accepts keys corresponding to the different embedders defined your index settings.
 * @summary Add or replace documents
 */
export const replaceDocuments = (
    indexUid: string,
    replaceDocumentsBody: unknown,
    params: ReplaceDocumentsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: replaceDocumentsBody,
        params, signal
    },
      options);
    }
  


export const getReplaceDocumentsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceDocuments>>, TError,{indexUid: string;data: unknown;params: ReplaceDocumentsParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof replaceDocuments>>, TError,{indexUid: string;data: unknown;params: ReplaceDocumentsParams}, TContext> => {

const mutationKey = ['replaceDocuments'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replaceDocuments>>, {indexUid: string;data: unknown;params: ReplaceDocumentsParams}> = (props) => {
          const {indexUid,data,params} = props ?? {};

          return  replaceDocuments(indexUid,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplaceDocumentsMutationResult = NonNullable<Awaited<ReturnType<typeof replaceDocuments>>>
    export type ReplaceDocumentsMutationBody = unknown
    export type ReplaceDocumentsMutationError = ResponseError

    /**
 * @summary Add or replace documents
 */
export const useReplaceDocuments = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceDocuments>>, TError,{indexUid: string;data: unknown;params: ReplaceDocumentsParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof replaceDocuments>>,
        TError,
        {indexUid: string;data: unknown;params: ReplaceDocumentsParams},
        TContext
      > => {

      const mutationOptions = getReplaceDocumentsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Delete all documents in the specified index.
 * @summary Delete all documents
 */
export const clearAllDocuments = (
    indexUid: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/documents`, method: 'DELETE'
    },
      options);
    }
  


export const getClearAllDocumentsMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearAllDocuments>>, TError,{indexUid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof clearAllDocuments>>, TError,{indexUid: string}, TContext> => {

const mutationKey = ['clearAllDocuments'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearAllDocuments>>, {indexUid: string}> = (props) => {
          const {indexUid} = props ?? {};

          return  clearAllDocuments(indexUid,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearAllDocumentsMutationResult = NonNullable<Awaited<ReturnType<typeof clearAllDocuments>>>
    
    export type ClearAllDocumentsMutationError = ResponseError

    /**
 * @summary Delete all documents
 */
export const useClearAllDocuments = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearAllDocuments>>, TError,{indexUid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof clearAllDocuments>>,
        TError,
        {indexUid: string},
        TContext
      > => {

      const mutationOptions = getClearAllDocumentsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Delete a set of documents based on a filter.
 * @summary Delete documents by filter
 */
export const deleteDocumentsByFilter = (
    indexUid: string,
    documentDeletionByFilter: DocumentDeletionByFilter,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/documents/delete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentDeletionByFilter, signal
    },
      options);
    }
  


export const getDeleteDocumentsByFilterMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentsByFilter>>, TError,{indexUid: string;data: DocumentDeletionByFilter}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentsByFilter>>, TError,{indexUid: string;data: DocumentDeletionByFilter}, TContext> => {

const mutationKey = ['deleteDocumentsByFilter'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocumentsByFilter>>, {indexUid: string;data: DocumentDeletionByFilter}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  deleteDocumentsByFilter(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentsByFilterMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocumentsByFilter>>>
    export type DeleteDocumentsByFilterMutationBody = DocumentDeletionByFilter
    export type DeleteDocumentsByFilterMutationError = ResponseError

    /**
 * @summary Delete documents by filter
 */
export const useDeleteDocumentsByFilter = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentsByFilter>>, TError,{indexUid: string;data: DocumentDeletionByFilter}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocumentsByFilter>>,
        TError,
        {indexUid: string;data: DocumentDeletionByFilter},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentsByFilterMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Use a [RHAI function](https://rhai.rs/book/engine/hello-world.html) to edit one or more documents directly in Meilisearch.
 * @summary Edit documents by function.
 */
export const editDocumentsByFunction = (
    indexUid: string,
    documentEditionByFunction: DocumentEditionByFunction,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/documents/edit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentEditionByFunction, signal
    },
      options);
    }
  


export const getEditDocumentsByFunctionMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editDocumentsByFunction>>, TError,{indexUid: string;data: DocumentEditionByFunction}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof editDocumentsByFunction>>, TError,{indexUid: string;data: DocumentEditionByFunction}, TContext> => {

const mutationKey = ['editDocumentsByFunction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editDocumentsByFunction>>, {indexUid: string;data: DocumentEditionByFunction}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  editDocumentsByFunction(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditDocumentsByFunctionMutationResult = NonNullable<Awaited<ReturnType<typeof editDocumentsByFunction>>>
    export type EditDocumentsByFunctionMutationBody = DocumentEditionByFunction
    export type EditDocumentsByFunctionMutationError = ResponseError

    /**
 * @summary Edit documents by function.
 */
export const useEditDocumentsByFunction = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editDocumentsByFunction>>, TError,{indexUid: string;data: DocumentEditionByFunction}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof editDocumentsByFunction>>,
        TError,
        {indexUid: string;data: DocumentEditionByFunction},
        TContext
      > => {

      const mutationOptions = getEditDocumentsByFunctionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get a set of documents.
 * @summary Get documents with POST
 */
export const documentsByQueryPost = (
    indexUid: string,
    browseQuery: BrowseQuery,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginationViewValue>(
      {url: `/indexes/${indexUid}/documents/fetch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: browseQuery, signal
    },
      options);
    }
  


export const getDocumentsByQueryPostMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsByQueryPost>>, TError,{indexUid: string;data: BrowseQuery}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof documentsByQueryPost>>, TError,{indexUid: string;data: BrowseQuery}, TContext> => {

const mutationKey = ['documentsByQueryPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentsByQueryPost>>, {indexUid: string;data: BrowseQuery}> = (props) => {
          const {indexUid,data} = props ?? {};

          return  documentsByQueryPost(indexUid,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentsByQueryPostMutationResult = NonNullable<Awaited<ReturnType<typeof documentsByQueryPost>>>
    export type DocumentsByQueryPostMutationBody = BrowseQuery
    export type DocumentsByQueryPostMutationError = ResponseError

    /**
 * @summary Get documents with POST
 */
export const useDocumentsByQueryPost = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsByQueryPost>>, TError,{indexUid: string;data: BrowseQuery}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof documentsByQueryPost>>,
        TError,
        {indexUid: string;data: BrowseQuery},
        TContext
      > => {

      const mutationOptions = getDocumentsByQueryPostMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get one document from its primary key.
 * @summary Get one document
 */
export const getDocument = (
    indexUid: string,
    documentId: string,
    params?: GetDocumentParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/indexes/${indexUid}/documents/${documentId}`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetDocumentQueryKey = (indexUid: string,
    documentId: string,
    params?: GetDocumentParams,) => {
    return [`/indexes/${indexUid}/documents/${documentId}`, ...(params ? [params]: [])] as const;
    }

    
export const useGetDocumentInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof getDocument>>, TError = ResponseError>(indexUid: string,
    documentId: string,
    params?: GetDocumentParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocument>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentQueryKey(indexUid,documentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocument>>> = ({ signal, pageParam }) => getDocument(indexUid,documentId,{...params, 'skip': pageParam || params?.['skip']}, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocument>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDocumentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDocument>>>
export type GetDocumentInfiniteQueryError = ResponseError


/**
 * @summary Get one document
 */

export function useGetDocumentInfinite<TData = Awaited<ReturnType<typeof getDocument>>, TError = ResponseError>(
 indexUid: string,
    documentId: string,
    params?: GetDocumentParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocument>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetDocumentInfiniteQueryOptions(indexUid,documentId,params,options)

  const query = useInfiniteQuery(queryOptions ) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const useGetDocumentQueryOptions = <TData = Awaited<ReturnType<typeof getDocument>>, TError = ResponseError>(indexUid: string,
    documentId: string,
    params?: GetDocumentParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDocument>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentQueryKey(indexUid,documentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocument>>> = ({ signal }) => getDocument(indexUid,documentId,params, requestOptions, signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof getDocument>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof getDocument>>>
export type GetDocumentQueryError = ResponseError


/**
 * @summary Get one document
 */

export function useGetDocument<TData = Awaited<ReturnType<typeof getDocument>>, TError = ResponseError>(
 indexUid: string,
    documentId: string,
    params?: GetDocumentParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDocument>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = useGetDocumentQueryOptions(indexUid,documentId,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Delete a single document by id.
 * @summary Delete a document
 */
export const deleteDocument = (
    indexUid: string,
    documentId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SummarizedTaskView>(
      {url: `/indexes/${indexUid}/documents/${documentId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDocumentMutationOptions = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocument>>, TError,{indexUid: string;documentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocument>>, TError,{indexUid: string;documentId: string}, TContext> => {

const mutationKey = ['deleteDocument'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocument>>, {indexUid: string;documentId: string}> = (props) => {
          const {indexUid,documentId} = props ?? {};

          return  deleteDocument(indexUid,documentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocument>>>
    
    export type DeleteDocumentMutationError = ResponseError

    /**
 * @summary Delete a document
 */
export const useDeleteDocument = <TError = ResponseError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocument>>, TError,{indexUid: string;documentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocument>>,
        TError,
        {indexUid: string;documentId: string},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentMutationOptions(options);

      return useMutation(mutationOptions );
    }
    